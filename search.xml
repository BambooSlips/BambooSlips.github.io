<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Android Camera</title>
      <link href="/2023/05/20/AndroidCameraScroll/"/>
      <url>/2023/05/20/AndroidCameraScroll/</url>
      
        <content type="html"><![CDATA[<p><img src="/images/Cameroid.jpeg" alt="Cameroid.jpeg"></p><h2 id="An-Overview-of-Activation-of-Android-Camera"><a href="#An-Overview-of-Activation-of-Android-Camera" class="headerlink" title="An Overview of Activation of Android Camera"></a>An Overview of Activation of Android Camera</h2><p>When a Android device boots up, the kernel will be loaded first. And then, CameraProvider will load CameraHAL, after which CameraService is able to communicate with CameraProvider to make use of CameraHAL.</p><p>When a APP trys taking control of the camera, Camera2 API will try getting CameraService, which will activate CameraProvider with the HIDL service. Finally, CameraHAL will call the driver.</p><p><img src="/images/CameroidSimple.jpeg" alt="CameroidSimple.jpeg"></p><h2 id="Activation-of-HwServiceManager"><a href="#Activation-of-HwServiceManager" class="headerlink" title="Activation of HwServiceManager"></a>Activation of HwServiceManager</h2><p>HwServiceManager is the management center of HIDL service, which is in control of all HIDL service in the system and started by the init process. And the CameraProvider is registered to it.</p><p>The script that start HwServiceManager up and used by the init process is hwservicemanager.rc.</p><pre><code class="hljs bash"><span class="hljs-comment"># system/hwservicemanager/hwservicemanager.rc</span>service hwservicemanager /system/bin/hwservicemanager    user system    disabled    group system readproc    critical    onrestart setprop hwservicemanager.ready <span class="hljs-literal">false</span>    onrestart class_restart main    onrestart class_restart hal    onrestart class_restart early_hal    writepid /dev/cpuset/system-background/tasks    class animation    shutdown critical</code></pre><p>And the source code of HwServiceManger is system/hwservicemanager/service.cpp. Let’s take a look at the main function.</p><pre><code class="hljs cpp"><span class="hljs-comment">/* system/hwservicemanager/service.cpp</span><span class="hljs-comment"> * main()</span><span class="hljs-comment"> */</span><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{    <span class="hljs-comment">// If hwservicemanager crashes, the system may be unstable and hard to debug. This is both why</span>    <span class="hljs-comment">// we log this and why we care about this at all.</span>    <span class="hljs-built_in">setProcessHidlReturnRestriction</span>(HidlReturnRestriction::ERROR_IF_UNCHECKED);    sp&lt;ServiceManager&gt; manager = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ServiceManager</span>();    <span class="hljs-built_in">setRequestingSid</span>(manager, <span class="hljs-literal">true</span>);    <span class="hljs-keyword">if</span> (!manager-&gt;<span class="hljs-built_in">add</span>(serviceName, manager).<span class="hljs-built_in">withDefault</span>(<span class="hljs-literal">false</span>)) {        <span class="hljs-built_in">ALOGE</span>(<span class="hljs-string">"Failed to register hwservicemanager with itself."</span>);    }    sp&lt;TokenManager&gt; tokenManager = <span class="hljs-keyword">new</span> <span class="hljs-built_in">TokenManager</span>();    <span class="hljs-keyword">if</span> (!manager-&gt;<span class="hljs-built_in">add</span>(serviceName, tokenManager).<span class="hljs-built_in">withDefault</span>(<span class="hljs-literal">false</span>)) {        <span class="hljs-built_in">ALOGE</span>(<span class="hljs-string">"Failed to register ITokenManager with hwservicemanager."</span>);    }    <span class="hljs-comment">// Tell IPCThreadState we're the service manager</span>    sp&lt;IBinder&gt; binder = <span class="hljs-built_in">toBinder</span>&lt;IServiceManager&gt;(manager);    sp&lt;BHwBinder&gt; service = <span class="hljs-built_in">static_cast</span>&lt;BHwBinder*&gt;(binder.<span class="hljs-built_in">get</span>()); <span class="hljs-comment">// local binder object</span>    IPCThreadState::<span class="hljs-built_in">self</span>()-&gt;<span class="hljs-built_in">setTheContextObject</span>(service);    <span class="hljs-comment">// Then tell the kernel</span>    ProcessState::<span class="hljs-built_in">self</span>()-&gt;<span class="hljs-built_in">becomeContextManager</span>(<span class="hljs-literal">nullptr</span>, <span class="hljs-literal">nullptr</span>);    <span class="hljs-type">int</span> rc = <span class="hljs-built_in">property_set</span>(<span class="hljs-string">"hwservicemanager.ready"</span>, <span class="hljs-string">"true"</span>);    <span class="hljs-keyword">if</span> (rc) {        <span class="hljs-built_in">ALOGE</span>(<span class="hljs-string">"Failed to set \"hwservicemanager.ready\" (error %d). "</span>\              <span class="hljs-string">"HAL services will not start!\n"</span>, rc);    }    sp&lt;Looper&gt; looper = Looper::<span class="hljs-built_in">prepare</span>(<span class="hljs-number">0</span> <span class="hljs-comment">/* opts */</span>);    (<span class="hljs-type">void</span>)HwBinderCallback::<span class="hljs-built_in">setupTo</span>(looper);    (<span class="hljs-type">void</span>)ClientCallbackCallback::<span class="hljs-built_in">setupTo</span>(looper, manager);    <span class="hljs-built_in">ALOGI</span>(<span class="hljs-string">"hwservicemanager is ready now."</span>);    <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) {        looper-&gt;<span class="hljs-built_in">pollAll</span>(<span class="hljs-number">-1</span> <span class="hljs-comment">/* timeoutMillis */</span>);    }    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;}</code></pre><p><img src="/images/CurousCameroid.jpeg" alt="CameroidSimple.jpeg"></p><h2 id="Activation-of-CameraProvider"><a href="#Activation-of-CameraProvider" class="headerlink" title="Activation of CameraProvider"></a>Activation of CameraProvider</h2><p>After HwServiceManager boots up, the booting of CameraProvider follows. Just like HwServiceManger, CameraProvider has its own booting script.</p><pre><code class="hljs bash"><span class="hljs-comment"># hardware/interfaces/camera/provider/2.4/default/android.hardware.camera.provider@2.4-service.rc</span>service vendor.camera-provider-2-4 /vendor/bin/hw/android.hardware.camera.provider@2.4-service    interface android.hardware.camera.provider@2.4::ICameraProvider legacy/0    class hal    user cameraserver    group audio camera input drmrpc    ioprio rt 4    capabilities SYS_NICE    task_profiles CameraServiceCapacity HighPerformance</code></pre><p>After compiling, there will be a script under /vendor/etc/init/, which is the folder of a Android device. And that script will start up CameraProvider.</p><pre><code class="hljs bash">AndroidDevice:/vendor/etc/init <span class="hljs-comment"># ls | grep "camera"</span>android.hardware.camera.provider@2.4-service_64.rcAndroidDevice:/vendor/etc/init <span class="hljs-comment"># cat android.hardware.camera.provider@2.4-service_64.rc</span><span class="hljs-comment">#! /bin/sh</span><span class="hljs-comment">#</span><span class="hljs-comment">#Copyright (c) 2019-2021 Qualcomm Technologies, Inc.</span><span class="hljs-comment">#All Rights Reserved.</span><span class="hljs-comment">#Confidential and Proprietary - Qualcomm Technologies, Inc.</span><span class="hljs-comment">#</span>on property:sys.boot_completed=1    <span class="hljs-comment"># Add a cpuset for the camera daemon</span>    <span class="hljs-comment"># We want all cores for camera</span>    <span class="hljs-built_in">mkdir</span> /dev/cpuset/camera-daemon    write /dev/cpuset/camera-daemon/cpus 0-7    write /dev/cpuset/camera-daemon/mems 0    <span class="hljs-built_in">chown</span> cameraserver cameraserver /dev/cpuset/camera-daemon    <span class="hljs-built_in">chown</span> cameraserver cameraserver /dev/cpuset/camera-daemon/tasks    <span class="hljs-built_in">chmod</span> 0660 /dev/cpuset/camera-daemon/tasksservice vendor.camera-provider-2-4 /vendor/bin/hw/android.hardware.camera.provider@2.4-service_64    override    interface android.hardware.camera.provider@2.4::ICameraProvider legacy/0    interface vendor.qti.hardware.camera.postproc@1.0::IPostProcService camerapostprocservice    class hal    user cameraserver    group audio camera input drmrpc oem_2907    ioprio rt 4    capabilities SYS_NICE    writepid /dev/cpuset/camera-daemon/tasks /dev/stune/foreground/tasks</code></pre><p>The source code about how CameraProvider starts follows.</p><pre><code class="hljs cpp"><span class="hljs-comment">/* hardware/interfaces/camera/provider/2.4/default/service.cpp</span><span class="hljs-comment"> * main()</span><span class="hljs-comment"> */</span><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>{    <span class="hljs-built_in">ALOGI</span>(<span class="hljs-string">"CameraProvider@2.4 legacy service is starting."</span>);    <span class="hljs-comment">// The camera HAL may communicate to other vendor components via</span>    <span class="hljs-comment">// /dev/vndbinder</span>    android::ProcessState::<span class="hljs-built_in">initWithDriver</span>(<span class="hljs-string">"/dev/vndbinder"</span>);    <span class="hljs-type">status_t</span> status;    <span class="hljs-keyword">if</span> (kLazyService) {        status = <span class="hljs-built_in">defaultLazyPassthroughServiceImplementation</span>&lt;ICameraProvider&gt;(<span class="hljs-string">"legacy/0"</span>,                                                                              <span class="hljs-comment">/*maxThreads*/</span> <span class="hljs-number">6</span>);    } <span class="hljs-keyword">else</span> {        status = <span class="hljs-built_in">defaultPassthroughServiceImplementation</span>&lt;ICameraProvider&gt;(<span class="hljs-string">"legacy/0"</span>,                                                                          <span class="hljs-comment">/*maxThreads*/</span> <span class="hljs-number">6</span>);    }    <span class="hljs-keyword">return</span> status;}</code></pre><p>As we can see above, the service will initialize the dirver and then start up CameraProvider.<br>The following sequence diagram found on the Internet will help understand how the service activate CameraProvider in a <code>Passthrough</code> way, which will register the HIDL service to HwServiceManager I mentioned earlier.<br><img src="/images/CameraProviderDequenceDiagram.png" alt="CameraProviderDequenceDiagram.png"></p><p>Especially, I’d like to record the source code of <code>CameraProvider_2_4</code> for a long-time reference.</p><pre><code class="hljs cpp"><span class="hljs-comment">/* CameraProvider_2_4.h */</span><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> ANDROID_HARDWARE_CAMERA_PROVIDER_V2_4_CAMERAPROVIDER_H</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> ANDROID_HARDWARE_CAMERA_PROVIDER_V2_4_CAMERAPROVIDER_H</span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;android/hardware/camera/provider/2.4/ICameraProvider.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;hidl/Status.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;hidl/MQDescriptor.h&gt;</span></span><span class="hljs-keyword">namespace</span> android {<span class="hljs-keyword">namespace</span> hardware {<span class="hljs-keyword">namespace</span> camera {<span class="hljs-keyword">namespace</span> provider {<span class="hljs-keyword">namespace</span> V2_4 {<span class="hljs-keyword">namespace</span> implementation {<span class="hljs-keyword">using</span> ::android::hardware::camera::common::V1_0::Status;<span class="hljs-keyword">using</span> ::android::hardware::camera::provider::V2_4::ICameraProvider;<span class="hljs-keyword">using</span> ::android::hardware::camera::provider::V2_4::ICameraProviderCallback;<span class="hljs-keyword">using</span> ::android::hardware::Return;<span class="hljs-keyword">using</span> ::android::hardware::hidl_string;<span class="hljs-keyword">using</span> ::android::sp;<span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> IMPL&gt;<span class="hljs-keyword">struct</span> <span class="hljs-title class_">CameraProvider</span> : <span class="hljs-keyword">public</span> ICameraProvider {    <span class="hljs-built_in">CameraProvider</span>() : <span class="hljs-built_in">impl</span>() {}    ~<span class="hljs-built_in">CameraProvider</span>() {}    <span class="hljs-comment">// Caller must use this method to check if CameraProvider ctor failed</span>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isInitFailed</span><span class="hljs-params">()</span> </span>{ <span class="hljs-keyword">return</span> impl.<span class="hljs-built_in">isInitFailed</span>(); }    <span class="hljs-comment">// Methods from ::android::hardware::camera::provider::V2_4::ICameraProvider follow.</span>    <span class="hljs-function">Return&lt;Status&gt; <span class="hljs-title">setCallback</span><span class="hljs-params">(<span class="hljs-type">const</span> sp&lt;ICameraProviderCallback&gt;&amp; callback)</span> <span class="hljs-keyword">override</span> </span>{        <span class="hljs-keyword">return</span> impl.<span class="hljs-built_in">setCallback</span>(callback);    }    <span class="hljs-function">Return&lt;<span class="hljs-type">void</span>&gt; <span class="hljs-title">getVendorTags</span><span class="hljs-params">(getVendorTags_cb _hidl_cb)</span> <span class="hljs-keyword">override</span> </span>{        <span class="hljs-keyword">return</span> impl.<span class="hljs-built_in">getVendorTags</span>(_hidl_cb);    }    <span class="hljs-function">Return&lt;<span class="hljs-type">void</span>&gt; <span class="hljs-title">getCameraIdList</span><span class="hljs-params">(getCameraIdList_cb _hidl_cb)</span> <span class="hljs-keyword">override</span> </span>{        <span class="hljs-keyword">return</span> impl.<span class="hljs-built_in">getCameraIdList</span>(_hidl_cb);    }    <span class="hljs-function">Return&lt;<span class="hljs-type">void</span>&gt; <span class="hljs-title">isSetTorchModeSupported</span><span class="hljs-params">(isSetTorchModeSupported_cb _hidl_cb)</span> <span class="hljs-keyword">override</span> </span>{        <span class="hljs-keyword">return</span> impl.<span class="hljs-built_in">isSetTorchModeSupported</span>(_hidl_cb);    }    <span class="hljs-function">Return&lt;<span class="hljs-type">void</span>&gt; <span class="hljs-title">getCameraDeviceInterface_V1_x</span><span class="hljs-params">(</span></span><span class="hljs-params"><span class="hljs-function">            <span class="hljs-type">const</span> hidl_string&amp; cameraDeviceName,</span></span><span class="hljs-params"><span class="hljs-function">            getCameraDeviceInterface_V1_x_cb _hidl_cb)</span> <span class="hljs-keyword">override</span> </span>{        <span class="hljs-keyword">return</span> impl.<span class="hljs-built_in">getCameraDeviceInterface_V1_x</span>(cameraDeviceName, _hidl_cb);    }    <span class="hljs-function">Return&lt;<span class="hljs-type">void</span>&gt; <span class="hljs-title">getCameraDeviceInterface_V3_x</span><span class="hljs-params">(</span></span><span class="hljs-params"><span class="hljs-function">            <span class="hljs-type">const</span> hidl_string&amp; cameraDeviceName,</span></span><span class="hljs-params"><span class="hljs-function">            getCameraDeviceInterface_V3_x_cb _hidl_cb)</span> <span class="hljs-keyword">override</span> </span>{        <span class="hljs-keyword">return</span> impl.<span class="hljs-built_in">getCameraDeviceInterface_V3_x</span>(cameraDeviceName, _hidl_cb);    }<span class="hljs-keyword">private</span>:    IMPL impl;};<span class="hljs-comment">////////////////////////////////////////////////////////////////////////////////</span><span class="hljs-comment">/* CameraProvider_2_4.cpp */</span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">"CameraProvider_2_4.h"</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">"LegacyCameraProviderImpl_2_4.h"</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">"ExternalCameraProviderImpl_2_4.h"</span></span><span class="hljs-type">const</span> <span class="hljs-type">char</span> *kLegacyProviderName = <span class="hljs-string">"legacy/0"</span>;<span class="hljs-type">const</span> <span class="hljs-type">char</span> *kExternalProviderName = <span class="hljs-string">"external/0"</span>;<span class="hljs-keyword">namespace</span> android {<span class="hljs-keyword">namespace</span> hardware {<span class="hljs-keyword">namespace</span> camera {<span class="hljs-keyword">namespace</span> provider {<span class="hljs-keyword">namespace</span> V2_4 {<span class="hljs-keyword">namespace</span> implementation {<span class="hljs-keyword">using</span> android::hardware::camera::provider::V2_4::ICameraProvider;<span class="hljs-keyword">extern</span> <span class="hljs-string">"C"</span> <span class="hljs-function">ICameraProvider* <span class="hljs-title">HIDL_FETCH_ICameraProvider</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span>* name)</span></span>;<span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> IMPL&gt;</span><span class="hljs-function">CameraProvider&lt;IMPL&gt;* <span class="hljs-title">getProviderImpl</span><span class="hljs-params">()</span> </span>{    CameraProvider&lt;IMPL&gt; *provider = <span class="hljs-keyword">new</span> <span class="hljs-built_in">CameraProvider</span>&lt;IMPL&gt;();    <span class="hljs-keyword">if</span> (provider == <span class="hljs-literal">nullptr</span>) {        <span class="hljs-built_in">ALOGE</span>(<span class="hljs-string">"%s: cannot allocate camera provider!"</span>, __FUNCTION__);        <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;    }    <span class="hljs-keyword">if</span> (provider-&gt;<span class="hljs-built_in">isInitFailed</span>()) {        <span class="hljs-built_in">ALOGE</span>(<span class="hljs-string">"%s: camera provider init failed!"</span>, __FUNCTION__);        <span class="hljs-keyword">delete</span> provider;        <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;    }    <span class="hljs-keyword">return</span> provider;}<span class="hljs-function">ICameraProvider* <span class="hljs-title">HIDL_FETCH_ICameraProvider</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span>* name)</span> </span>{    <span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> android::hardware::camera::provider::V2_4::implementation;    ICameraProvider* provider = <span class="hljs-literal">nullptr</span>;    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">strcmp</span>(name, kLegacyProviderName) == <span class="hljs-number">0</span>) {        provider = <span class="hljs-built_in">getProviderImpl</span>&lt;LegacyCameraProviderImpl_2_4&gt;();    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-built_in">strcmp</span>(name, kExternalProviderName) == <span class="hljs-number">0</span>) {        provider = <span class="hljs-built_in">getProviderImpl</span>&lt;ExternalCameraProviderImpl_2_4&gt;();        provider = <span class="hljs-built_in">getProviderImpl</span>&lt;ExternalCameraProviderImpl_2_4&gt;();    } <span class="hljs-keyword">else</span> {        <span class="hljs-built_in">ALOGE</span>(<span class="hljs-string">"%s: unknown instance name: %s"</span>, __FUNCTION__, name);    }    <span class="hljs-keyword">return</span> provider;}}  <span class="hljs-comment">// namespace implementation</span>}  <span class="hljs-comment">// namespace V2_4</span>}  <span class="hljs-comment">// namespace provider</span></code></pre><p>And the real implementaion that calls CameraHAL is in the following source files:</p><pre><code class="hljs bash">i@host:~/Code/android$ find hardware/interfaces/camera/provider/2.4/default/ -name <span class="hljs-string">"*CameraProviderImpl*"</span>hardware/interfaces/camera/provider/2.4/default/ExternalCameraProviderImpl_2_4.cpphardware/interfaces/camera/provider/2.4/default/ExternalCameraProviderImpl_2_4.hhardware/interfaces/camera/provider/2.4/default/LegacyCameraProviderImpl_2_4.cpphardware/interfaces/camera/provider/2.4/default/LegacyCameraProviderImpl_2_4.h</code></pre><p>Let’s take a look at the constructor and initializer.</p><pre><code class="hljs cpp"><span class="hljs-comment">//hardware/interfaces/camera/provider/2.4/default/LegacyCameraProviderImpl_2_4.h</span><span class="hljs-keyword">struct</span> <span class="hljs-title class_">LegacyCameraProviderImpl_2_4</span> : <span class="hljs-keyword">public</span> <span class="hljs-type">camera_module_callbacks_t</span> { <span class="hljs-comment">/* ... */</span> }<span class="hljs-comment">////////////////////////////////////////////////////////////////////////////////</span><span class="hljs-comment">//hardware/interfaces/camera/provider/2.4/default/LegacyCameraProviderImpl_2_4.cpp</span>LegacyCameraProviderImpl_2_4::<span class="hljs-built_in">LegacyCameraProviderImpl_2_4</span>() :        <span class="hljs-built_in">camera_module_callbacks_t</span>({sCameraDeviceStatusChange,                                   sTorchModeStatusChange}) {    mInitFailed = <span class="hljs-built_in">initialize</span>();}<span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">LegacyCameraProviderImpl_2_4::initialize</span><span class="hljs-params">()</span> </span>{    <span class="hljs-type">camera_module_t</span> *rawModule;    <span class="hljs-type">int</span> err = <span class="hljs-built_in">hw_get_module</span>(CAMERA_HARDWARE_MODULE_ID,            (<span class="hljs-type">const</span> <span class="hljs-type">hw_module_t</span> **)&amp;rawModule);    <span class="hljs-keyword">if</span> (err &lt; <span class="hljs-number">0</span>) {        <span class="hljs-built_in">ALOGE</span>(<span class="hljs-string">"Could not load camera HAL module: %d (%s)"</span>, err, <span class="hljs-built_in">strerror</span>(-err));        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;    }    mModule = <span class="hljs-keyword">new</span> <span class="hljs-built_in">CameraModule</span>(rawModule);    err = mModule-&gt;<span class="hljs-built_in">init</span>();    <span class="hljs-keyword">if</span> (err != OK) {        <span class="hljs-built_in">ALOGE</span>(<span class="hljs-string">"Could not initialize camera HAL module: %d (%s)"</span>, err, <span class="hljs-built_in">strerror</span>(-err));        mModule.<span class="hljs-built_in">clear</span>();        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;    }    <span class="hljs-built_in">ALOGI</span>(<span class="hljs-string">"Loaded \"%s\" camera module"</span>, mModule-&gt;<span class="hljs-built_in">getModuleName</span>());    <span class="hljs-comment">// Setup vendor tags here so HAL can setup vendor keys in camera characteristics</span>    VendorTagDescriptor::<span class="hljs-built_in">clearGlobalVendorTagDescriptor</span>();    <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">setUpVendorTags</span>()) {        <span class="hljs-built_in">ALOGE</span>(<span class="hljs-string">"%s: Vendor tag setup failed, will not be available."</span>, __FUNCTION__);    }    <span class="hljs-comment">// Setup callback now because we are going to try openLegacy next</span>    err = mModule-&gt;<span class="hljs-built_in">setCallbacks</span>(<span class="hljs-keyword">this</span>);    <span class="hljs-keyword">if</span> (err != OK) {        <span class="hljs-built_in">ALOGE</span>(<span class="hljs-string">"Could not set camera module callback: %d (%s)"</span>, err, <span class="hljs-built_in">strerror</span>(-err));        mModule.<span class="hljs-built_in">clear</span>();        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;    }    mPreferredHal3MinorVersion =        <span class="hljs-built_in">property_get_int32</span>(<span class="hljs-string">"ro.vendor.camera.wrapper.hal3TrebleMinorVersion"</span>, <span class="hljs-number">3</span>);    <span class="hljs-built_in">ALOGV</span>(<span class="hljs-string">"Preferred HAL 3 minor version is %d"</span>, mPreferredHal3MinorVersion);    <span class="hljs-keyword">switch</span>(mPreferredHal3MinorVersion) {        <span class="hljs-keyword">case</span> <span class="hljs-number">2</span>:        <span class="hljs-keyword">case</span> <span class="hljs-number">3</span>:            <span class="hljs-comment">// OK</span>            <span class="hljs-keyword">break</span>;        <span class="hljs-keyword">default</span>:            <span class="hljs-built_in">ALOGW</span>(<span class="hljs-string">"Unknown minor camera device HAL version %d in property "</span>                    <span class="hljs-string">"'camera.wrapper.hal3TrebleMinorVersion', defaulting to 3"</span>,                    mPreferredHal3MinorVersion);            mPreferredHal3MinorVersion = <span class="hljs-number">3</span>;    }    mNumberOfLegacyCameras = mModule-&gt;<span class="hljs-built_in">getNumberOfCameras</span>();    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; mNumberOfLegacyCameras; i++) {        <span class="hljs-type">uint32_t</span> device_version;        <span class="hljs-keyword">auto</span> rc = mModule-&gt;<span class="hljs-built_in">getCameraDeviceVersion</span>(i, &amp;device_version);        <span class="hljs-keyword">if</span> (rc != NO_ERROR) {            <span class="hljs-built_in">ALOGE</span>(<span class="hljs-string">"%s: Camera device version query failed!"</span>, __func__);            mModule.<span class="hljs-built_in">clear</span>();            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;        }        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">checkCameraVersion</span>(i, device_version) != OK) {            <span class="hljs-built_in">ALOGE</span>(<span class="hljs-string">"%s: Camera version check failed!"</span>, __func__);            mModule.<span class="hljs-built_in">clear</span>();            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;        }        <span class="hljs-type">char</span> cameraId[kMaxCameraIdLen];        <span class="hljs-built_in">snprintf</span>(cameraId, <span class="hljs-built_in">sizeof</span>(cameraId), <span class="hljs-string">"%d"</span>, i);        <span class="hljs-function">std::string <span class="hljs-title">cameraIdStr</span><span class="hljs-params">(cameraId)</span></span>;        mCameraStatusMap[cameraIdStr] = CAMERA_DEVICE_STATUS_PRESENT;        <span class="hljs-built_in">addDeviceNames</span>(i);    }    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>; <span class="hljs-comment">// mInitFailed</span>}</code></pre><p>And here follows related structures.</p><pre><code class="hljs cpp"><span class="hljs-comment">//hardware/libhardware/include/hardware/camera_common.h</span><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">camera_module</span> {    <span class="hljs-comment">/**</span><span class="hljs-comment">     * Common methods of the camera module.  This *must* be the first member of</span><span class="hljs-comment">     * camera_module as users of this structure will cast a hw_module_t to</span><span class="hljs-comment">     * camera_module pointer in contexts where it's known the hw_module_t</span><span class="hljs-comment">     * references a camera_module.</span><span class="hljs-comment">     */</span>    <span class="hljs-type">hw_module_t</span> common;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * get_number_of_cameras:</span><span class="hljs-comment">     *</span><span class="hljs-comment">     * Returns the number of camera devices accessible through the camera</span><span class="hljs-comment">     * module.  The camera devices are numbered 0 through N-1, where N is the</span><span class="hljs-comment">     * value returned by this call. The name of the camera device for open() is</span><span class="hljs-comment">     * simply the number converted to a string. That is, "0" for camera ID 0,</span><span class="hljs-comment">     * "1" for camera ID 1.</span><span class="hljs-comment">     */</span>    <span class="hljs-built_in">int</span> (*get_number_of_cameras)(<span class="hljs-type">void</span>);    <span class="hljs-comment">/**</span><span class="hljs-comment">     * get_camera_info:</span><span class="hljs-comment">     *</span><span class="hljs-comment">     * Return the static camera information for a given camera device. This</span><span class="hljs-comment">     * information may not change for a camera device.</span><span class="hljs-comment">     */</span>    <span class="hljs-built_in">int</span> (*get_camera_info)(<span class="hljs-type">int</span> camera_id, <span class="hljs-keyword">struct</span> camera_info *info);    <span class="hljs-comment">/**</span><span class="hljs-comment">     * set_callbacks:</span><span class="hljs-comment">     *</span><span class="hljs-comment">     * Provide callback function pointers to the HAL module to inform framework</span><span class="hljs-comment">     * of asynchronous camera module events. The framework will call this</span><span class="hljs-comment">     * function once after initial camera HAL module load, after the</span><span class="hljs-comment">     * get_number_of_cameras() method is called for the first time, and before</span><span class="hljs-comment">     * any other calls to the module.</span><span class="hljs-comment">     */</span>    <span class="hljs-built_in">int</span> (*set_callbacks)(<span class="hljs-type">const</span> <span class="hljs-type">camera_module_callbacks_t</span> *callbacks);    <span class="hljs-comment">/**</span><span class="hljs-comment">     * get_vendor_tag_ops:</span><span class="hljs-comment">     *</span><span class="hljs-comment">     * Get methods to query for vendor extension metadata tag information. The</span><span class="hljs-comment">     * HAL should fill in all the vendor tag operation methods, or leave ops</span><span class="hljs-comment">     * unchanged if no vendor tags are defined.</span><span class="hljs-comment">     */</span>    <span class="hljs-built_in">void</span> (*get_vendor_tag_ops)(<span class="hljs-type">vendor_tag_ops_t</span>* ops);    <span class="hljs-comment">/**</span><span class="hljs-comment">     * open_legacy:</span><span class="hljs-comment">     *</span><span class="hljs-comment">     * Open a specific legacy camera HAL device if multiple device HAL API</span><span class="hljs-comment">     * versions are supported by this camera HAL module. For example, if the</span><span class="hljs-comment">     * camera module supports both CAMERA_DEVICE_API_VERSION_1_0 and</span><span class="hljs-comment">     * CAMERA_DEVICE_API_VERSION_3_2 device API for the same camera id,</span><span class="hljs-comment">     * framework can call this function to open the camera device as</span><span class="hljs-comment">     * CAMERA_DEVICE_API_VERSION_1_0 device.</span><span class="hljs-comment">     */</span>    <span class="hljs-built_in">int</span> (*open_legacy)(<span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> <span class="hljs-type">hw_module_t</span>* <span class="hljs-keyword">module</span>, <span class="hljs-type">const</span> <span class="hljs-type">char</span>* id,            <span class="hljs-type">uint32_t</span> halVersion, <span class="hljs-keyword">struct</span> <span class="hljs-type">hw_device_t</span>** device);    <span class="hljs-comment">/**</span><span class="hljs-comment">     * set_torch_mode:</span><span class="hljs-comment">     *</span><span class="hljs-comment">     * Turn on or off the torch mode of the flash unit associated with a given</span><span class="hljs-comment">     * camera ID. If the operation is successful, HAL must notify the framework</span><span class="hljs-comment">     * torch state by invoking</span><span class="hljs-comment">     * camera_module_callbacks.torch_mode_status_change() with the new state.</span><span class="hljs-comment">     */</span>    <span class="hljs-built_in">int</span> (*set_torch_mode)(<span class="hljs-type">const</span> <span class="hljs-type">char</span>* camera_id, <span class="hljs-type">bool</span> enabled);    <span class="hljs-comment">/**</span><span class="hljs-comment">     * init:</span><span class="hljs-comment">     *</span><span class="hljs-comment">     * This method is called by the camera service before any other methods</span><span class="hljs-comment">     * are invoked, right after the camera HAL library has been successfully</span><span class="hljs-comment">     * loaded. It may be left as NULL by the HAL module, if no initialization</span><span class="hljs-comment">     * in needed.</span><span class="hljs-comment">     *</span><span class="hljs-comment">     * It can be used by HAL implementations to perform initialization and</span><span class="hljs-comment">     * other one-time operations.</span><span class="hljs-comment">     */</span>    <span class="hljs-built_in">int</span> (*init)();    <span class="hljs-comment">/**</span><span class="hljs-comment">     * get_physical_camera_info:</span><span class="hljs-comment">     *</span><span class="hljs-comment">     * Return the static metadata for a physical camera as a part of a logical</span><span class="hljs-comment">     * camera device. This function is only called for those physical camera</span><span class="hljs-comment">     * ID(s) that are not exposed independently. In other words, camera_id will</span><span class="hljs-comment">     * be greater or equal to the return value of get_number_of_cameras().</span><span class="hljs-comment">     */</span>    <span class="hljs-built_in">int</span> (*get_physical_camera_info)(<span class="hljs-type">int</span> physical_camera_id,            <span class="hljs-type">camera_metadata_t</span> **static_metadata);    <span class="hljs-comment">/**</span><span class="hljs-comment">     * is_stream_combination_supported:</span><span class="hljs-comment">     *</span><span class="hljs-comment">     * Check for device support of specific camera stream combination.</span><span class="hljs-comment">     */</span>    <span class="hljs-built_in">int</span> (*is_stream_combination_supported)(<span class="hljs-type">int</span> camera_id,            <span class="hljs-type">const</span> <span class="hljs-type">camera_stream_combination_t</span> *streams);    <span class="hljs-comment">/**</span><span class="hljs-comment">     * notify_device_state_change:</span><span class="hljs-comment">     *</span><span class="hljs-comment">     * Notify the camera module that the state of the overall device has</span><span class="hljs-comment">     * changed in some way that the HAL may want to know about.</span><span class="hljs-comment">     */</span>    <span class="hljs-built_in">void</span> (*notify_device_state_change)(<span class="hljs-type">uint64_t</span> deviceState);    <span class="hljs-comment">/**</span><span class="hljs-comment">     * get_camera_device_version:</span><span class="hljs-comment">     *</span><span class="hljs-comment">     * Return the device version for a given camera device. This value may not change for a camera</span><span class="hljs-comment">     * device. The version returned here must be the same as the one from get_camera_info.</span><span class="hljs-comment">     */</span>    <span class="hljs-built_in">int</span> (*get_camera_device_version)(<span class="hljs-type">int</span> camera_id, <span class="hljs-type">uint32_t</span> *version);    <span class="hljs-comment">/* reserved for future use */</span>    <span class="hljs-type">void</span>* reserved[<span class="hljs-number">1</span>];} <span class="hljs-type">camera_module_t</span>;<span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">camera_module_callbacks</span> {    <span class="hljs-comment">/**</span><span class="hljs-comment">     * camera_device_status_change:</span><span class="hljs-comment">     *</span><span class="hljs-comment">     * Callback to the framework to indicate that the state of a specific camera</span><span class="hljs-comment">     * device has changed. At module load time, the framework will assume all</span><span class="hljs-comment">     * camera devices are in the CAMERA_DEVICE_STATUS_PRESENT state. The HAL</span><span class="hljs-comment">     * must call this method to inform the framework of any initially</span><span class="hljs-comment">     * NOT_PRESENT devices.</span><span class="hljs-comment">     *</span><span class="hljs-comment">     * This callback is added for CAMERA_MODULE_API_VERSION_2_1.</span><span class="hljs-comment">     *</span><span class="hljs-comment">     * camera_module_callbacks: The instance of camera_module_callbacks_t passed</span><span class="hljs-comment">     *   to the module with set_callbacks.</span><span class="hljs-comment">     *</span><span class="hljs-comment">     * camera_id: The ID of the camera device that has a new status.</span><span class="hljs-comment">     *</span><span class="hljs-comment">     * new_status: The new status code, one of the camera_device_status_t enums,</span><span class="hljs-comment">     *   or a platform-specific status.</span><span class="hljs-comment">     *</span><span class="hljs-comment">     */</span>    <span class="hljs-built_in">void</span> (*camera_device_status_change)(<span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> camera_module_callbacks*,            <span class="hljs-type">int</span> camera_id,            <span class="hljs-type">int</span> new_status);    <span class="hljs-comment">/**</span><span class="hljs-comment">     * torch_mode_status_change:</span><span class="hljs-comment">     *</span><span class="hljs-comment">     * Callback to the framework to indicate that the state of the torch mode</span><span class="hljs-comment">     * of the flash unit associated with a specific camera device has changed.</span><span class="hljs-comment">     * At module load time, the framework will assume the torch modes are in</span><span class="hljs-comment">     * the TORCH_MODE_STATUS_AVAILABLE_OFF state if android.flash.info.available</span><span class="hljs-comment">     * is reported as true via get_camera_info() call.</span><span class="hljs-comment">     *</span><span class="hljs-comment">     * This callback is added for CAMERA_MODULE_API_VERSION_2_4.</span><span class="hljs-comment">     *</span><span class="hljs-comment">     * camera_module_callbacks: The instance of camera_module_callbacks_t</span><span class="hljs-comment">     *   passed to the module with set_callbacks.</span><span class="hljs-comment">     *</span><span class="hljs-comment">     * camera_id: The ID of camera device whose flash unit has a new torch mode</span><span class="hljs-comment">     *   status.</span><span class="hljs-comment">     *</span><span class="hljs-comment">     * new_status: The new status code, one of the torch_mode_status_t enums.</span><span class="hljs-comment">     */</span>    <span class="hljs-built_in">void</span> (*torch_mode_status_change)(<span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> camera_module_callbacks*,            <span class="hljs-type">const</span> <span class="hljs-type">char</span>* camera_id,            <span class="hljs-type">int</span> new_status);} <span class="hljs-type">camera_module_callbacks_t</span>;</code></pre><p>As a conclusion, CameraHAL is accessible to CameraProvider, whcih is registered to HwServiceManager after activation. Therefore, when other service needs the CameraHAL, it just needs to communicate with CameraProvider. </p><p><img src="/images/CameraHAL.jpeg" alt="CameroidSimple.jpeg"></p><h2 id="Activation-of-CameraHAL"><a href="#Activation-of-CameraHAL" class="headerlink" title="Activation of CameraHAL"></a>Activation of CameraHAL</h2><p>As we can see in <code>LegacyCameraProviderImpl_2_4::initialize()</code>, CameraHAL is initialized with class <code>CameraModule</code>, which is a wrapper class for HAL camera module.</p><pre><code class="hljs cpp"><span class="hljs-comment">// hardware/interfaces/camera/common/1.0/default/include/CameraModule.h</span><span class="hljs-keyword">class</span> <span class="hljs-title class_">CameraModule</span> : <span class="hljs-keyword">public</span> RefBase {<span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">CameraModule</span><span class="hljs-params">(<span class="hljs-type">camera_module_t</span> *<span class="hljs-keyword">module</span>)</span></span>;    <span class="hljs-keyword">virtual</span> ~<span class="hljs-built_in">CameraModule</span>();    <span class="hljs-comment">// Must be called after construction</span>    <span class="hljs-comment">// Returns OK on success, NO_INIT on failure</span>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">init</span><span class="hljs-params">()</span></span>;    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">getCameraDeviceVersion</span><span class="hljs-params">(<span class="hljs-type">int</span> cameraId, <span class="hljs-type">uint32_t</span>* version)</span></span>;    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">getCameraInfo</span><span class="hljs-params">(<span class="hljs-type">int</span> cameraId, <span class="hljs-keyword">struct</span> camera_info *info)</span></span>;    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">getDeviceVersion</span><span class="hljs-params">(<span class="hljs-type">int</span> cameraId)</span></span>;    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">getNumberOfCameras</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span>;    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">open</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span>* id, <span class="hljs-keyword">struct</span> <span class="hljs-type">hw_device_t</span>** device)</span></span>;    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isOpenLegacyDefined</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">openLegacy</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span>* id, <span class="hljs-type">uint32_t</span> halVersion, <span class="hljs-keyword">struct</span> <span class="hljs-type">hw_device_t</span>** device)</span></span>;    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">setCallbacks</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">camera_module_callbacks_t</span> *callbacks)</span></span>;    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isVendorTagDefined</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">getVendorTagOps</span><span class="hljs-params">(<span class="hljs-type">vendor_tag_ops_t</span>* ops)</span></span>;    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isSetTorchModeSupported</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">setTorchMode</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span>* camera_id, <span class="hljs-type">bool</span> enable)</span></span>;    <span class="hljs-function"><span class="hljs-type">uint16_t</span> <span class="hljs-title">getModuleApiVersion</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;    <span class="hljs-function"><span class="hljs-type">const</span> <span class="hljs-type">char</span>* <span class="hljs-title">getModuleName</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;    <span class="hljs-function"><span class="hljs-type">uint16_t</span> <span class="hljs-title">getHalApiVersion</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;    <span class="hljs-function"><span class="hljs-type">const</span> <span class="hljs-type">char</span>* <span class="hljs-title">getModuleAuthor</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;    <span class="hljs-comment">// Only used by CameraModuleFixture native test. Do NOT use elsewhere.</span>    <span class="hljs-function"><span class="hljs-type">void</span> *<span class="hljs-title">getDso</span><span class="hljs-params">()</span></span>;    <span class="hljs-comment">// Only used by CameraProvider</span>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">removeCamera</span><span class="hljs-params">(<span class="hljs-type">int</span> cameraId)</span></span>;    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">getPhysicalCameraInfo</span><span class="hljs-params">(<span class="hljs-type">int</span> physicalCameraId, <span class="hljs-type">camera_metadata_t</span> **physicalInfo)</span></span>;    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">isStreamCombinationSupported</span><span class="hljs-params">(<span class="hljs-type">int</span> cameraId, <span class="hljs-type">camera_stream_combination_t</span> *streams)</span></span>;    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">notifyDeviceStateChange</span><span class="hljs-params">(<span class="hljs-type">uint64_t</span> deviceState)</span></span>;    <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">bool</span> <span class="hljs-title">isLogicalMultiCamera</span><span class="hljs-params">(</span></span><span class="hljs-params"><span class="hljs-function">            <span class="hljs-type">const</span> common::V1_0::helper::CameraMetadata&amp; metadata,</span></span><span class="hljs-params"><span class="hljs-function">            std::unordered_set&lt;std::string&gt;* physicalCameraIds)</span></span>;<span class="hljs-keyword">private</span>:    <span class="hljs-comment">// Derive camera characteristics keys defined after HAL device version</span>    <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">deriveCameraCharacteristicsKeys</span><span class="hljs-params">(<span class="hljs-type">uint32_t</span> deviceVersion, CameraMetadata &amp;chars)</span></span>;    <span class="hljs-comment">// Helper function to append available[request|result|chars]Keys</span>    <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">appendAvailableKeys</span><span class="hljs-params">(CameraMetadata &amp;chars,</span></span><span class="hljs-params"><span class="hljs-function">            <span class="hljs-type">int32_t</span> keyTag, <span class="hljs-type">const</span> Vector&lt;<span class="hljs-type">int32_t</span>&gt;&amp; appendKeys)</span></span>;    <span class="hljs-function"><span class="hljs-type">status_t</span> <span class="hljs-title">filterOpenErrorCode</span><span class="hljs-params">(<span class="hljs-type">status_t</span> err)</span></span>;    <span class="hljs-type">camera_module_t</span> *mModule;    <span class="hljs-type">int</span> mNumberOfCameras;    KeyedVector&lt;<span class="hljs-type">int</span>, camera_info&gt; mCameraInfoMap;    KeyedVector&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; mDeviceVersionMap;    KeyedVector&lt;<span class="hljs-type">int</span>, <span class="hljs-type">camera_metadata_t</span>*&gt; mPhysicalCameraInfoMap;    Mutex mCameraInfoLock;};} <span class="hljs-comment">// namespace helper</span>} <span class="hljs-comment">// namespace V1_0</span>} <span class="hljs-comment">// namespace common</span>} <span class="hljs-comment">// namespace camera</span>} <span class="hljs-comment">// namespace hardware</span>} <span class="hljs-comment">// namespace android</span><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><span class="hljs-comment">////////////////////////////////////////////////////////////////////////////////</span><span class="hljs-comment">// hardware/interfaces/camera/common/1.0/default/CameraModule.cpp</span>CameraModule::<span class="hljs-built_in">CameraModule</span>(<span class="hljs-type">camera_module_t</span> *<span class="hljs-keyword">module</span>) : <span class="hljs-built_in">mNumberOfCameras</span>(<span class="hljs-number">0</span>) {    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">module</span> == <span class="hljs-literal">NULL</span>) {        <span class="hljs-built_in">ALOGE</span>(<span class="hljs-string">"%s: camera hardware module must not be null"</span>, __FUNCTION__);        <span class="hljs-built_in">assert</span>(<span class="hljs-number">0</span>);    }    mModule = <span class="hljs-keyword">module</span>;}<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">CameraModule::init</span><span class="hljs-params">()</span> </span>{    <span class="hljs-built_in">ATRACE_CALL</span>();    <span class="hljs-type">int</span> res = OK;    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">getModuleApiVersion</span>() &gt;= CAMERA_MODULE_API_VERSION_2_4 &amp;&amp;            mModule-&gt;init != <span class="hljs-literal">NULL</span>) {        <span class="hljs-built_in">ATRACE_BEGIN</span>(<span class="hljs-string">"camera_module-&gt;init"</span>);        res = mModule-&gt;<span class="hljs-built_in">init</span>();        <span class="hljs-built_in">ATRACE_END</span>();    }    mNumberOfCameras = <span class="hljs-built_in">getNumberOfCameras</span>();    mCameraInfoMap.<span class="hljs-built_in">setCapacity</span>(mNumberOfCameras);    <span class="hljs-keyword">return</span> res;}<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">CameraModule::setCallbacks</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">camera_module_callbacks_t</span> *callbacks)</span> </span>{    <span class="hljs-type">int</span> res = OK;    <span class="hljs-built_in">ATRACE_BEGIN</span>(<span class="hljs-string">"camera_module-&gt;set_callbacks"</span>);    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">getModuleApiVersion</span>() &gt;= CAMERA_MODULE_API_VERSION_2_1) {        res = mModule-&gt;<span class="hljs-built_in">set_callbacks</span>(callbacks);    }    <span class="hljs-built_in">ATRACE_END</span>();    <span class="hljs-keyword">return</span> res;}<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">CameraModule::getNumberOfCameras</span><span class="hljs-params">()</span> </span>{    <span class="hljs-type">int</span> numCameras;    <span class="hljs-built_in">ATRACE_BEGIN</span>(<span class="hljs-string">"camera_module-&gt;get_number_of_cameras"</span>);    numCameras = mModule-&gt;<span class="hljs-built_in">get_number_of_cameras</span>();    <span class="hljs-built_in">ATRACE_END</span>();    <span class="hljs-keyword">return</span> numCameras;}</code></pre><p>By the way, the RefBase appeared above is a class provides a lightweight reference counting mechanism to manage the lifecycle of objects, which further avoids problems such as memory leaks and dangling pointers.</p><p>To understand the <code>CameraModule.cpp</code>, the following source code may help.</p><pre><code class="hljs bash">i@host:~/Code/android$ find hardware/ -name <span class="hljs-string">"camera.h"</span> -o -name <span class="hljs-string">"hardware.h"</span>hardware/libhardware/modules/camera/3_4/camera.hhardware/libhardware/include/hardware/hardware.hhardware/libhardware/include/hardware/camera.h</code></pre><pre><code class="hljs cpp"><span class="hljs-comment">// hardware/libhardware/include/hardware/hardware.h</span><span class="hljs-comment">/**</span><span class="hljs-comment"> * Get the module info associated with a module by id.</span><span class="hljs-comment"> *</span><span class="hljs-comment"> * @return: 0 == success, &lt;0 == error and *module == NULL</span><span class="hljs-comment"> */</span><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">hw_get_module</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *id, <span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> <span class="hljs-type">hw_module_t</span> **<span class="hljs-keyword">module</span>)</span></span>;</code></pre><p>Here follows a sequence diagram I drew to show this process more visually and clearly.</p><p><img src="/images/CameraProvider&amp;CamerHAL.png" alt="CameraProvider&amp;CamerHAL.png"></p>]]></content>
      
      
      
        <tags>
            
            <tag> Android </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HIDL</title>
      <link href="/2022/08/23/HIDLScroll/"/>
      <url>/2022/08/23/HIDLScroll/</url>
      
        <content type="html"><![CDATA[<h2 id="Overview"><a href="#Overview" class="headerlink" title="Overview"></a>Overview</h2><p>Camera框架分为五层，即APP、Service、Provider、Driver及Hardware：</p><p><img src="/images/androidCamArch.png" alt="alt Android Camera Architecture"></p><p>由上图可知，HIDL位于Service和Provider层之间。HIDL即HAL接口定义语言（Hardware Interface Definition Language, 发音为“hide-l”），它是用于指定HAL和用户之间接口的一种接口描述语言（IDL）。但根据google官方资料，从Android之后，HIDL已被废弃，Android将在其所有位置改用AIDL。</p><p>HIDL旨在用于进程间的通信（IPC），它成功地将Camera Hal MOdule从Camera Service中解耦出来，并承担着对Camera HAL的封装工作，减轻并降低了开发者的工作量和开发难度。</p><h2 id="HIDL开发"><a href="#HIDL开发" class="headerlink" title="HIDL开发"></a>HIDL开发</h2><h3 id="Android源码的下载与编译"><a href="#Android源码的下载与编译" class="headerlink" title="Android源码的下载与编译"></a>Android源码的下载与编译</h3><h4 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h4><p>首先在Manjaro中安装Repo:</p><pre><code class="hljs bash">yay -S repo</code></pre><p>获取最新版本:</p><pre><code class="hljs bash">repo init -u https://android.googlesource.com/platform/manifest</code></pre><p>或指定版本：</p><pre><code class="hljs code">repo init -u https://android.googlesource.com/platform/manifest -b master</code></pre><p>下载源码树：</p><pre><code class="hljs code">repo sync</code></pre><p>加快速度：</p><pre><code class="hljs bash"><span class="hljs-comment"># -c: 当前分支， -j:线程数</span>repo <span class="hljs-built_in">sync</span> -c -j8</code></pre><h4 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h4><p>待续……</p>]]></content>
      
      
      
        <tags>
            
            <tag> Android </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CamX &amp; Chi</title>
      <link href="/2022/08/23/CamX&amp;ChiScroll/"/>
      <url>/2022/08/23/CamX&amp;ChiScroll/</url>
      
        <content type="html"><![CDATA[<h2 id="Overview"><a href="#Overview" class="headerlink" title="Overview"></a>Overview</h2><p>CamX-CHI架构是为了更精细化控制底层硬件，同时方便手机厂商自定义一些功能而提出的。它将一些高度统一的功能性接口抽离出来放到CamX中，将可定制化的部分放到CHI中供厂商修改以实现各自独有的特色功能。这样做的好处是：即便开发者对CamX不是很了解，也可以很方便地加入自定义的功能，从而降低开发者在高通平台的开发门槛。</p><h3 id="目录结构"><a href="#目录结构" class="headerlink" title="目录结构"></a>目录结构</h3><p><img src="/images/CamX-CHI_dir.png" alt="alt CamX-CHI目录结构"></p><p>图中CamX代表了功能性接口的代码实现集合，CHI则代表了可定制化需求的代码实现集合。CamX对上作为HAL3接口的实现，对下通过V4L2框架与Kernel保持通讯，并以互相dlopen so库的方式与CHI交互以获取对方的操作接口。</p><h4 id="各个目录的用途"><a href="#各个目录的用途" class="headerlink" title="各个目录的用途"></a>各个目录的用途</h4><p>待续……</p><h2 id="各个部件"><a href="#各个部件" class="headerlink" title="各个部件"></a>各个部件</h2><h3 id="Usecase"><a href="#Usecase" class="headerlink" title="Usecase"></a>Usecase</h3><p>Usecase是CamX-CHI中最大的抽象概念，其中包含这多条用于实现特定功能的Pipeline，其具体实现主要是通过Usecase类完成。Usecase主要负责业务处理及资源管理。</p><h4 id="主要接口"><a href="#主要接口" class="headerlink" title="主要接口"></a>主要接口</h4><p>待续……</p><h3 id="Feature"><a href="#Feature" class="headerlink" title="Feature"></a>Feature</h3><p>一个Feature表示一个特定的功能，它需要多条Pipeline组合实现，受到Usecase的统一管理，其具体实现是CHI中的Feature类。在XML中没有对应的定义时，具体的Feature的选取是通过在Usecase中完成的，通过在创建Feature的时候，传入Usecase的实例的方式来和Usecase进行相互访问各自的资源。从Feature基类派生出了很多子类：</p><p><img src="/images/FetureFather.png" alt="alt Feture Father and its Children"></p><h3 id="Session"><a href="#Session" class="headerlink" title="Session"></a>Session</h3><p>Session是用于管理pipeline的抽象控制单元，一个Session中至少拥有一个pipeline。Session控制着所有的硬件资源，管控着内部的每一个pipeline的request的流转及数据的输入输出，它没有可定制化的部分，所以在CHI中的XML文件中没有将Session作为一个独立的单元进行定义。</p><h4 id="主要接口-1"><a href="#主要接口-1" class="headerlink" title="主要接口"></a>主要接口</h4><p>Session的主要实现是通过CamX中的Session类，其只要接口包括：</p><p>待续……</p><h3 id="Pipeline"><a href="#Pipeline" class="headerlink" title="Pipeline"></a>Pipeline</h3><p>Pipeline是提供单一特定功能的所有资源的集合，它维护着所有硬件资源及数据的流转，每一个Pipeline包括了其中的Node/Line，在CamX中通过Pipeline类实现。</p><h4 id="主要接口-2"><a href="#主要接口-2" class="headerlink" title="主要接口"></a>主要接口</h4><p>待续……</p><h3 id="Node"><a href="#Node" class="headerlink" title="Node"></a>Node</h3><p>Node是具有独立处理功能的抽象模块，它可以是硬件单元，也可以是软件但愿。Node是的具体实现是CamX中的Node类，而在CamX-CHI中主要分为两大类：高通自己实现的Node包括硬件Node和CHI中提供给用户进行实现的Node。</p><h4 id="具体接口"><a href="#具体接口" class="headerlink" title="具体接口"></a>具体接口</h4><p>待续……</p><h3 id="Link"><a href="#Link" class="headerlink" title="Link"></a>Link</h3><p>Link用于定于不同的Port连接。一个Port可以根据需要在与其从属不同的Port间建立多条连接。每个Link都包含了分别代表输入、输出端口的一个SrcPort和一个DstPort。两个端口之间的buffer配置用BufferProperties表示。</p><h3 id="Port"><a href="#Port" class="headerlink" title="Port"></a>Port</h3><p>Port是Node的输入或输出端口。在XML文件中，可以用标签来定义输入输出端口。每个Node均可以根据需要使用若干输入输出端口。</p><h4 id="相关结构体"><a href="#相关结构体" class="headerlink" title="相关结构体"></a>相关结构体</h4><p>待续……</p><h2 id="组件的结构关系"><a href="#组件的结构关系" class="headerlink" title="组件的结构关系"></a>组件的结构关系</h2><p><img src="/images/CamXCompStructure.png" alt="atl 组件结构"></p><h2 id="关键流程"><a href="#关键流程" class="headerlink" title="关键流程"></a>关键流程</h2><h3 id="Camera-Provider-初始化"><a href="#Camera-Provider-初始化" class="headerlink" title="Camera Provider 初始化"></a>Camera Provider 初始化</h3><p>Camera Provider会随着系统的启动而启动，其在初始化的过程中会通过获取的camera_module_t调用其get_number_of_camera接口以获取底层支持的camera数量。第一次获取时还会进行一系列的初始化动作：<br><img src="/images/getCameraNumber.png" alt="alt 获取camera数量"></p><ol><li>读取vendor/etc/camera/camxoverridesettings.txt</li><li>获取底层支持的硬件信息</li><li>读取/vendor/lib64/camera/components中的各个Node生成的so库，并存入ExternalComponentInfo中</li></ol><p>除此之外，在初始化阶段，CamX与CHI还通过相互dlopen对方的so库获取了对方的入口方法，然后通过彼此的入口方法获取对方的操作方法集合，最后通过这些操作方法与对方进行通讯：</p><p><img src="/images/CamX-CHI_talking_init.png" alt="alt 初始化时CamX与CHI的交互"></p><h3 id="打开相机设备-初始化相机设备"><a href="#打开相机设备-初始化相机设备" class="headerlink" title="打开相机设备/初始化相机设备"></a>打开相机设备/初始化相机设备</h3><p>待续……</p>]]></content>
      
      
      
        <tags>
            
            <tag> Android </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Android Anatomy</title>
      <link href="/2022/06/15/AndroidAnatomyScroll/"/>
      <url>/2022/06/15/AndroidAnatomyScroll/</url>
      
        <content type="html"><![CDATA[<p><img src="/images/android_anatomy.png" alt="Android Anatomy"></p><h2 id="Android三窥"><a href="#Android三窥" class="headerlink" title="Android三窥"></a>Android三窥</h2><p>首先，分别从Android的层次结构、服务模型和源代码这三个不同的角度一窥Android系统。</p><h3 id="Android-Layer-Cake"><a href="#Android-Layer-Cake" class="headerlink" title="Android Layer Cake"></a>Android Layer Cake</h3><p>下图是Android系统的层次模型，其左半部分可以看作一个如同Ubuntu的一般的Linux发行版本，而右半部分则是Android系统的特定组成部分。</p><p><img src="/images/AndroidLayerCake.jpg" alt="Android Layer Cake"></p><p>该模型将Android分为四个主要层次，每一层都基于其下一层，从下至上依次是：硬件层、Linux内核层、系统库层以及应用和系统服务层。目前，大多数的Android开发者主要的工作集中于上图的“Android Applications”区域，他们将时间用于学习和利用Android系统提供的环境。而本文的主要内容是关于如何自定义Android系统本身以使其适用于新的硬件。</p><h4 id="硬件层"><a href="#硬件层" class="headerlink" title="硬件层"></a>硬件层</h4><p>硬件层即物理设备，它处于当前模型的最底层。</p><h4 id="Linux内核层"><a href="#Linux内核层" class="headerlink" title="Linux内核层"></a>Linux内核层</h4><p>内核是创造进程及所有应用运行的内存环境的软件。Android的内核是一种Linux内核的变体，它是Android系统的首要移植层。将Android移植到一个新设备上的过程包括将一个Android的Linux内核变体运行在目标设备上，然后将Android的其它部分放置其上。另外，在Android中，Java源代码并不是被编译为JVM的指令，而是被编译为Dalvik和ART的指令。Android VM的目标是使得应用在Android设备间可移植，而不是和JVM一样，使得它们在多平台和系统间可移植。</p><h4 id="系统库层"><a href="#系统库层" class="headerlink" title="系统库层"></a>系统库层</h4><p>系统库即软件库，它通常是由第三方提供的不透明的二进制文件，用于实现用于多个应用的服务。一些会被多个应用用到的通用功能，如密码系统、影音和web浏览器较为复杂，将它们实现为可被多个应用使用的库是很合情合理的。<br>在Android的系统库的众多组成中，Bionic尤为值得特殊注意。可以说，Bionic相当于Android的标准C库。大部分应用并不直接请求内核的服务，而是使用C标准库请求内核服务。C标准库接口一开始是ANSI(American National Standards Institute) C 标准的一部分，后来也逐渐为ISO所接受。而现在广认可的POSIX(Portable Operating System Interface of UNIX) C 标准库则是一个对其有所增加的父集。<br>随着Android对于节简的追求，Bionic已经被无情地精简了很多。较之其BSD(Berkly Software Distribution)的祖先，它已经小了很多，以至于它已不能满足ANSI标准，更不用说POSIX标准了。所以，在其它平台上运行地很好的应用，可能因为Bionic不支持其所需的函数而根本不能在Android上面运行。<br>另外，Bionic根源于BSD。不同于大部分操作系统基于一个使用某一版本的GNU C标注库(glibc)，Android的Bionic源于BSD UNIX的libc。这样做的原因很多，其中一个原因就是libc得到了BSD的许可，这样它便不会如同glibc一样受到加于其上的LGPL(GNU Lesser General Public License)的约束。</p><h4 id="应用和系统服务层"><a href="#应用和系统服务层" class="headerlink" title="应用和系统服务层"></a>应用和系统服务层</h4><p>应用使用由更底层提供的环境向用户提供服务。一些特殊的，持续运行的应用被称为系统服务，有时候也被称为守护进程（daemons)，它们执行周期性的任务，管理系统状态。</p><h3 id="The-Android-Service-Model"><a href="#The-Android-Service-Model" class="headerlink" title="The Android Service Model"></a>The Android Service Model</h3><h3 id="The-Source"><a href="#The-Source" class="headerlink" title="The Source"></a>The Source</h3>]]></content>
      
      
      
        <tags>
            
            <tag> Android </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>软件测试 Software Testing</title>
      <link href="/2021/05/27/TestScroll/"/>
      <url>/2021/05/27/TestScroll/</url>
      
        <content type="html"><![CDATA[<p><img src="/images/st1.png" alt="st1"></p><h2 id="软件测试的概念"><a href="#软件测试的概念" class="headerlink" title="软件测试的概念"></a>软件测试的概念</h2><h3 id="软件"><a href="#软件" class="headerlink" title="软件"></a>软件</h3><p>软件=程序+文档</p><h3 id="软件测试"><a href="#软件测试" class="headerlink" title="软件测试"></a>软件测试</h3><p>软件测试（Software Testing），描述一种用来促进鉴定软件的正确性、完整性、安全性和质量的过程。换句话说，软件测试是一种实际输出与预期输出之间的审核或者比较过程。软件测试的经典定义是：在规定的条件下对程序进行操作，以发现程序错误，衡量软件质量，并对其是否能满足设计要求进行评估的过程。</p><h3 id="缺陷"><a href="#缺陷" class="headerlink" title="缺陷"></a>缺陷</h3><h4 id="什么是软件缺陷"><a href="#什么是软件缺陷" class="headerlink" title="什么是软件缺陷"></a>什么是软件缺陷</h4><ul><li>没有实现《需求规格说明书》中需要实现的功能</li><li>实现了《需求规格说明书》中没有提到的功能</li><li>实现了基本功能，但未实现一些虽未明确规定但应该实现的目标，如软件难以理解，不易使用，运行缓慢等</li></ul><h4 id="产生原因"><a href="#产生原因" class="headerlink" title="产生原因"></a>产生原因</h4><ul><li>软件产品说明书（需求）</li><li>设计</li><li>编写代码</li><li>其它</li></ul><h3 id="测试用例"><a href="#测试用例" class="headerlink" title="测试用例"></a>测试用例</h3><ul><li>定义：在测试执行之前设计的一套详细的测试方案，包括测试环境、测试步骤、测试数据和预期结果</li><li>测试用例=输入+输出+测试环境<ul><li>输入：测试数据和操作步骤</li><li>输出：期望结果</li><li>测试环境：系统环境设置</li></ul></li><li>设计测试用例是创造性劳动，而执行测试用例是体力劳动，设计测试用例是软件测试的关键</li></ul><h2 id="黑盒测试"><a href="#黑盒测试" class="headerlink" title="黑盒测试"></a>黑盒测试</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><ul><li><p>又叫功能测试，数据驱动测试或基于规格说明的测试。（实际上，黑盒测试包括功能测试和性能测试）</p></li><li><p>测试过程</p><pre><code class="hljs mermaid">graph LRA[需求说明] --&gt; |产生| B[被测程序] --&gt;|输出| C[测试结果]C[测试结果] --&gt;|比较| A[需求说明]</code></pre></li><li><p>黑盒测试的难点在于如何构造有效的输入</p><ul><li>由于输入空间通常是无限的，穷举测试显然行不通。 </li><li>寻找最小最重要的用例集合以精简测试复杂性。</li></ul></li></ul><h3 id="除因果图外各种方法"><a href="#除因果图外各种方法" class="headerlink" title="除因果图外各种方法"></a>除因果图外各种方法</h3><h4 id="边界值分析"><a href="#边界值分析" class="headerlink" title="边界值分析"></a>边界值分析</h4><h5 id="基本原理"><a href="#基本原理" class="headerlink" title="基本原理"></a>基本原理</h5><h5 id="基本思想"><a href="#基本思想" class="headerlink" title="基本思想"></a>基本思想</h5><ul><li>在最小值、略高于最小值、正常值、略低于最大值和最大值处取输入变量值 </li><li>表示方法min、min+、nom、max-和max</li></ul><h5 id="边界值分析获得测试用例的方法"><a href="#边界值分析获得测试用例的方法" class="headerlink" title="边界值分析获得测试用例的方法"></a>边界值分析获得测试用例的方法</h5><ul><li>使所有变量取正常值，只使一个变量取极值； </li><li>对于一个n变量函数，边界值分析会产生4n+1个测试用例。</li></ul><h5 id="两个变量函数边界值分析测试用例"><a href="#两个变量函数边界值分析测试用例" class="headerlink" title="两个变量函数边界值分析测试用例"></a>两个变量函数边界值分析测试用例</h5><ul><li>X1取值：x1min,x1min+,x1nom,x1max-,x1max </li><li>X2取值：x2min,x2min+ ,x2nom,x2max-,x2max</li></ul><h5 id="健壮性测试"><a href="#健壮性测试" class="headerlink" title="健壮性测试"></a>健壮性测试</h5><h4 id="基于判定表的测试"><a href="#基于判定表的测试" class="headerlink" title="基于判定表的测试"></a>基于判定表的测试</h4><h5 id="判定表的组成"><a href="#判定表的组成" class="headerlink" title="判定表的组成"></a>判定表的组成</h5><ul><li>条件桩（Condition Stub）<br>列出问题的所有条件 </li><li>动作桩（Action Stub）<br>列出可能采取的操作 </li><li>条件项（Condition Entity）<br>列出条件桩的取值 </li><li>动作项（Action Entity）<br>列出条件项各种取值下应该采取的动作</li></ul><h5 id="判定表的组成-1"><a href="#判定表的组成-1" class="headerlink" title="判定表的组成"></a>判定表的组成</h5><h5 id="规则合并"><a href="#规则合并" class="headerlink" title="规则合并"></a>规则合并</h5><ul><li>规则合并就是判定表的简化。 </li><li>有两条或多条规则具有相同的动作，并且其条件项之间存在着极为相似的关系，就可以将规则合并。</li></ul><h5 id="判定表建立步骤"><a href="#判定表建立步骤" class="headerlink" title="判定表建立步骤"></a>判定表建立步骤</h5><ul><li>根据软件规格说明<br>① 列出所有的条件桩和动作桩；<br>② 确定规则的个数；<br> 假如有n个条件，每个条件有两个取值（0,1）,则有2^n 种规则；<br>③ 填入条件项；<br>④ 填入动作项，得到初始决策表；<br>⑤ 简化，合并相似规则（相同动作）。</li></ul><h5 id="判定表的优点"><a href="#判定表的优点" class="headerlink" title="判定表的优点"></a>判定表的优点</h5><ul><li>能把复杂的问题按各种可能的情况一一列举出来 </li><li>简明而易于理解 </li><li>可避免遗漏</li></ul><h5 id="判定表的缺点"><a href="#判定表的缺点" class="headerlink" title="判定表的缺点"></a>判定表的缺点</h5><ul><li><p>不能表达重复执行的动作，例如循环结构 </p></li><li><p>判定表不能很好地伸缩 </p></li><li><p>有n个条件的决策表有2^n 个规则</p></li></ul><h4 id="场景法"><a href="#场景法" class="headerlink" title="场景法"></a>场景法</h4><h3 id="划分等价类"><a href="#划分等价类" class="headerlink" title="划分等价类"></a>划分等价类</h3><h4 id="等价类定义"><a href="#等价类定义" class="headerlink" title="等价类定义"></a>等价类定义</h4><p>等价类是输入域的某个子集合，而所有的等价类的并集是整个输入域。在子集合中，各个输入数据对于揭露程序中的错误是等效的。</p><h4 id="有效等价类"><a href="#有效等价类" class="headerlink" title="有效等价类"></a>有效等价类</h4><p>对于程序的规格说明来说，是合理的、有意义的输入数据所构成的集合；</p><h4 id="无效等价类"><a href="#无效等价类" class="headerlink" title="无效等价类"></a>无效等价类</h4><p>对于程序的规格说明来说，是不合理的、没有意义的输入数据所构成的集合</p><h4 id="确定等价类的原则"><a href="#确定等价类的原则" class="headerlink" title="确定等价类的原则"></a>确定等价类的原则</h4><ul><li>如果输入条件规定了取值范围或值的个数就可确定一个有效等价类和两个无效等价类</li><li>如果输入条件是一个布尔量,则可以确立一个有效等价类和一个无效等价类。</li><li>如果规定了输入数据的一组值, 且程序要对每一个输入值分别进行处理, 要对每一个规定的输入值确立一个有效等价类,而对于这组值之外的所有值确立一个无效等价类。</li><li>如果规定了输入数据必须遵循的规则，可确定一个有效等价类和若干个无效等价类（从不同角度违反规则)。 （其他情况）</li><li>如已划分的等价类各元素在程序中的处理方式不同，则应将此等价类进一步划分成更小的等价类</li></ul><h4 id="用等价类设计测试用例"><a href="#用等价类设计测试用例" class="headerlink" title="用等价类设计测试用例"></a>用等价类设计测试用例</h4><ul><li>分析输入输出，划分等价类，形成等价类表； </li><li>设计一新的测试用例，使其尽可能多地覆盖尚未覆盖的有效等价类，重复这一步骤，直到所有的有效等价类都被覆盖为止； </li><li>设计一新测试用例，使其只覆盖一个无效等价类，重复这一步骤直到所有无效等价类均被覆盖；</li></ul><h3 id="写测试用例"><a href="#写测试用例" class="headerlink" title="写测试用例"></a>写测试用例</h3><h2 id="Web测试"><a href="#Web测试" class="headerlink" title="Web测试"></a>Web测试</h2><h3 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h3><blockquote><p>如：搜索功能如何测试（角度）</p></blockquote><h4 id="表单测试"><a href="#表单测试" class="headerlink" title="表单测试"></a>表单测试</h4><ul><li>测试方法<ul><li>边界值测试</li><li>等价类测试</li><li>异常类测试</li></ul></li><li>文本框测试常见验证点<ul><li>输入正常的字母或数字，验证是否能正常工作。</li><li>输入已存在的用户名或电子邮件名称，验证是否有唯一性校验。</li><li>输入超长字符串，例如在“名称”框中输入超过允许边界个数的字符，假设最多255字符，尝试输入256个或以上字符，检查程序能否正确处理。</li><li>输入默认值，空白，空格，检查程序能否正确处理。</li><li>若只允许输入字母，尝试输入数字；反之；尝试输入字母，检查程序能否正确处理。</li><li>利用复制，粘贴等操作强制输入程序不允许的输入数据，检查程序能否正确处理。</li><li>输入特殊字符集，例如，NULL及\n等，检查程序能否正确处理。</li><li>输入中文、英文、数字、特殊字符（特别注意单引号和反斜杠）及这四类的混合输入，检查程序能否正确处理。</li><li>输入不符合格式的数据，检查程序是否正常校验，如：程序要求输入身份证号，</li><li>输入abc123，程序应该给出错误提示。</li><li>输入html语言的&lt;head&gt;、&lt;html&gt;、&lt;b&gt;等，检查是否能原样正确显示。</li><li>输入全角、半角的英文、数字、特殊字符等，检查是否报错。</li></ul></li><li>特殊输入域常见验证点<ul><li>密码框测试常见验证点<ul><li>密码输入域输入数据是否可见？密码的正确显示必须为“******”，不可见模式。</li><li>密码是否可以全部是空格？密码设计必须不能全为空格。</li><li>密码是否对大小写敏感？比如：密码“An@d123R”与“an@d123r”，一定不是同一个密码。</li></ul></li><li>日期填充域常见验证点 <ul><li>输入不符合格式的数据，检查程序是否正常校验，如：程序要求输入年月日格式为yy/mm/dd，实际输入yyyy/mm/dd，程序应该给出错误提示。</li><li>无效日期处理，如：出生年月输入为2013/02/30，我们知道2月最多是29天，检查程序是否出错。</li><li>出生日期填写为未来日期，比如3214/12/12，检查程序是否出错。</li><li>将结束日期设置在开始日期之前，检查是否有正常校验。</li></ul></li><li>电话号码填充域常见验证点<ul><li>电话号码应该由一组数字组成，不能包含英文字母。</li><li>如果有分机号，中间用破折号分隔。</li></ul></li><li>邮政编码填充域常见验证点<ul><li>国内的邮政编码都是数字。</li><li>英国的邮编是字母与数字的组合，当我们测试国外邮编时需要先查一下该国的邮编格式。</li></ul></li><li>电子邮件填充域常见验证点<ul><li>电子邮件的格式为：<a href="mailto:xyz@xyz.xyz">xyz@xyz.xyz</a>，输入错误的格式比如：aa@aa，123，aa#aa.aa，检查是否有错误提示。</li><li>输入正确的电子邮件地址，需要能验证通过，并能收到相应的Email。</li></ul></li><li>购物数量填充域常见验证点<ul><li>在填写购物数量的地方，输入一个最大值，查看钱数累计的是否正确；</li><li>在填写购物数量的地方，输入一个负数，检查是否有正确的处理；</li><li>在填写购物数量的地方，输入一个数字0，检查是否有正确的处理；</li><li>在填写购物数量的地方，输入一个字母a，检查是否有正确的处理；</li><li>在填写购物数量的地方，输入一个特殊符号&gt;，检查页面能否正确显示。</li></ul></li><li>必填字段常见验证点<ul><li>必填字段不输入任何内容，直接提交，检查是否有错误提示；</li><li>必填字段只输入空格，然后提交，检查是否有错误提示；</li><li>必填字段的提示是否统一。</li></ul></li><li>单选按钮常见验证点<ul><li>一组单选按钮不能同时选中，只能选中一个；</li><li>逐一执行每个单选按钮的功能。分别选择了“男”、“女”后，保存到数据库的数据应该相应的分别为“男”、“女”；</li><li>一组执行同一功能的单选按钮在初始状态时必须有一个被默认选中，不能同时为空。</li></ul></li><li>复选框常见验证点<ul><li>多个复选框可以被同时选中（全选）；</li><li>多个复选框可以被部分选中（部分选）；</li><li>多个复选框可以都不被选中（全不选）；</li><li>逐一执行每个复选框的功能（选择保存后，查看保存结果是与所选择的一致）。</li></ul></li><li>大块文字区域常见验证点<ul><li>输入数据超出最大字符数，检查会出什么情况；</li><li>输入数据正好为最大字符数，检查是否能正确保存；</li><li>不输入任何数据，检查是否能正确保存；</li><li>在Firefox或Chrome浏览器下，大块文字区域右下角一般都可以拖放，尝试用鼠标进行拖放，检查会不会导致界面很难看或滚动条消失。</li></ul></li><li>下拉列表框常见验证点<ul><li>条目内容正确，无重复条目，无遗失条目；</li><li>逐一执行列表框中每个条目的功能。</li></ul></li><li>排序常见验证点<ul><li>选择正序排列后，再检查一下反序排序；</li><li>对文字的排序，检查是否按从A到Z的顺序；</li><li>对价格、数目等的排序，检查是否按数字大小顺序；</li><li>如果有分页，检查是否先好排序再分页。</li></ul></li><li>分页测试常见验证点：<ul><li>当没有数据时，首页、上一页、下一页、尾页标签全部置灰，不支持点击；</li><li>在首页时，“首页”“上一页”标签置灰；在尾页时，“下一页”“尾页”标签置灰；在中间页时，四个标签均可点击，且跳转正确；</li><li>翻页后，列表中的数据是否仍按照指定的顺序进行了排序；</li><li>各个分页标签是否在同一水平线上；</li><li>各个页面的分页标签样式是否一致；</li><li>分页的总页数及当前页数显示是否正确；</li><li>是否能正确跳转到指定的页数；</li><li>在分页处输入非数字的字符（英文、特殊字符等），输入0或超出总页数的数字，是否有友好提示信息；</li><li>是否支持回车键的监听。</li></ul></li><li>搜索框填充域常见验证点<ul><li>搜索按钮功能是否实现；</li><li>输入网站中存在的信息，能否正确搜索出结果；</li><li>输入键盘中所有特殊字符，是否报错；特别关注：_？＇＂# \ / – &lt; &gt;；特殊字符；</li><li>搜索出的结果页面是否与其他页面风格一致；</li><li>在输入域输入空格，点击搜索系统是否报错；</li><li>本站内搜索输入域中不输入任何内容，是否搜索出的是全部信息或者给予提示信息；</li><li>输入NULL/null、或很长的字符串，会出现什么结果；</li><li>精确查询还是模糊查询，如果是模糊查询输入：中%国（中*国），查询结果是不是都包含中国两个字的信息；</li><li>焦点放置搜索框中，搜索框默认内容是否自动被清空；</li><li>搜索输入域是否实现回车键监听事件。</li></ul></li><li>用户登录常见验证点<ul><li>用户名和密码都符合要求并且是正确的，检查是否能登录成功；</li><li>用户名和密码都不符合格式要求，检查是否能登录成功以及出错提示；</li><li>用户名符合要求，密码不符合要求，检查是否能登录成功以及出错提示；</li><li>密码符合要求，用户名不符合要求，检查是否能登录成功以及出错提示；</li><li>用户名或密码为空，检查是否能登录成功以及出错提示；</li><li>数据库中不存在的用户名，不存在的密码，检查是否能登录成功以及出错提示；</li><li>数据库中存在的用户名，错误的密码，检查是否能登录成功以及出错提示；</li><li>数据库中不存在的用户名，存在的密码，检查是否能登录成功以及出错提示；</li><li>输入的用户名或密码前存在空格，检查是否能登录成功以及出错提示；<br>按键盘上的回车键是否监听事件，能执行登录过程。</li></ul></li></ul></li></ul><h4 id="界面测试"><a href="#界面测试" class="headerlink" title="界面测试"></a>界面测试</h4><p>用户界面测试，英文是User interface testing，又称UI Testing，是指软件中的可见外观及其底层与用户交互的部分，包括菜单、对话框、窗口和其它控件。</p><ul><li>文字重叠问题</li><li>字符显示不完整</li><li>乱码</li><li>Tooltip对应不同</li><li>菜单对应不一致</li><li>鼠标变小手</li><li>不同浏览器显示问题</li><li>不同版本浏览器显示问题</li><li>不同OS &amp; Browser显示问题</li><li>对齐问题</li><li>图片显示问题</li><li>各个页面的样式风格是否统一 </li><li>各个页面的标题Title是否正确</li><li>导航处是否按相应的栏目级别显示</li><li>所有的图片是否都被正确装载，在不同的浏览器、分辨率下图片是否能正确显示（包括位置、大小）</li><li>窗口缩小</li><li>……</li></ul><h4 id="功能测试"><a href="#功能测试" class="headerlink" title="功能测试"></a>功能测试</h4><p>功能测试（Functional testing）。Web应用程序中的功能测试主要是对页面的链接、按钮等页面元素功能是否正常工作的测试。</p><ul><li>链接问题<ul><li>链接不工作</li><li>空链接</li><li>链接页面错误</li></ul></li><li>按钮问题<ul><li>按钮不工作</li><li>点击按钮产生JSerror</li></ul></li><li>本身应该具有的功能<ul><li>该有的功能没有实现</li><li>该有的功能错误对应到另一功能</li></ul></li><li>提示问题<ul><li>缺少提示</li><li>提示信息错误</li><li>提示导致UI问题</li></ul></li></ul><h4 id="安全测试"><a href="#安全测试" class="headerlink" title="安全测试"></a>安全测试</h4><ul><li><p>编辑框</p><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span>alert(“XSS”)<span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></code></pre></li><li><p>URL</p><pre><code class="hljs html">URL+<span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span>alert(“XSS”)<span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></code></pre></li><li><p>修改URL</p><p>修改URL导致显示其他内容</p></li><li><p>SQL注入</p></li></ul><h3 id="写缺陷报告"><a href="#写缺陷报告" class="headerlink" title="写缺陷报告"></a>写缺陷报告</h3><p><img src="/images/image-20210527100653918.png" alt="image-20210527100653918"></p><h3 id="selenium写代码"><a href="#selenium写代码" class="headerlink" title="selenium写代码"></a>selenium写代码</h3><ul><li><p>Elements can be accessed in many ways:</p><ul><li><p>Element attribute: </p><ul><li><p>name</p><pre><code class="hljs java">driver.findElement(By.name(<span class="hljs-string">"password"</span>)).sendKeys(“aaaa<span class="hljs-string">");</span></code></pre></li><li><p>id</p><pre><code class="hljs java">driver.findElement(By.id(<span class="hljs-string">"user"</span>)).sendKeys(<span class="hljs-string">"wangtianci"</span>);</code></pre></li><li><p>value</p></li></ul></li><li><p>Xpath </p><pre><code class="hljs java">driver.findElement(By.xpath(<span class="hljs-string">"//[@id=\"kw\"]"</span>)).sendKeys(<span class="hljs-string">"selenium"</span>);</code></pre></li><li><p>LinkText</p><pre><code class="hljs java">driver.findElement(By.linkText(<span class="hljs-string">"学术"</span>)).click();</code></pre></li></ul></li><li><p>User actions that can be emulated:</p><ul><li>Click</li><li>Filling out text fields (sending keys)</li></ul></li></ul><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.List;<span class="hljs-keyword">import</span> org.openqa.selenium.By;<span class="hljs-keyword">import</span> org.openqa.selenium.WebDriver;<span class="hljs-keyword">import</span> org.openqa.selenium.chrome.ChromeDriver;<span class="hljs-keyword">import</span> org.openqa.selenium.support.ui.Select;<span class="hljs-keyword">import</span> org.openqa.selenium.WebElement;<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">App</span> {    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">WebDriver</span> <span class="hljs-variable">driver</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ChromeDriver</span>();    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception {        System.out.println(<span class="hljs-string">"Hello, World!"</span>);        System.setProperty(<span class="hljs-string">"webdriver.chrome.driver"</span>,<span class="hljs-string">"/usr/bin/chromedriver"</span>);        <span class="hljs-comment">//亚马逊</span>        driver.get(<span class="hljs-string">"https://www.amazon.com/?currency=USD&amp;language=en_US"</span>);        <span class="hljs-comment">//选择搜索类别--书籍</span>        selectItem(<span class="hljs-string">"search-alias=stripbooks-intl-ship"</span>);        <span class="hljs-comment">//搜索“selenium design patterns"</span>        search(<span class="hljs-string">"selenium design patterns"</span>);        <span class="hljs-comment">//选择结果第一项</span>        chooseResult();        <span class="hljs-comment">//加入购物车并查看购物车</span>        addToCart();            }    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sleep</span><span class="hljs-params">(<span class="hljs-type">int</span> time)</span> {        <span class="hljs-keyword">try</span> {            Thread.sleep(time);        } <span class="hljs-keyword">catch</span> (InterruptedException e) {            <span class="hljs-comment">// TODO Auto-generated catch block</span>            e.printStackTrace();        }    }    <span class="hljs-comment">//选择搜索类别</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">selectItem</span><span class="hljs-params">(String value)</span>{        sleep(<span class="hljs-number">2000</span>);        <span class="hljs-type">WebElement</span> <span class="hljs-variable">formElement</span> <span class="hljs-operator">=</span> driver.findElement        (By.id(<span class="hljs-string">"searchDropdownBox"</span>));        sleep(<span class="hljs-number">1000</span>);        <span class="hljs-type">Select</span> <span class="hljs-variable">downList</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Select</span>(formElement);        downList.selectByValue(value);        List&lt;WebElement&gt; list = downList.getAllSelectedOptions();        <span class="hljs-keyword">for</span>(WebElement option : list) {            System.out.println(option.getText());        }        System.out.println(downList.getFirstSelectedOption().getText());    }    <span class="hljs-comment">//搜索</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">search</span><span class="hljs-params">(String keywords)</span> {        sleep(<span class="hljs-number">1000</span>);        <span class="hljs-type">WebElement</span> <span class="hljs-variable">searchBox</span> <span class="hljs-operator">=</span> driver.findElement(By.id(<span class="hljs-string">"twotabsearchtextbox"</span>));        searchBox.sendKeys(keywords);        <span class="hljs-type">WebElement</span> <span class="hljs-variable">searchButton</span> <span class="hljs-operator">=</span> driver.findElement(By.id(<span class="hljs-string">"nav-search-submit-button"</span>));        searchButton.click();        System.out.println(<span class="hljs-string">"Searching..."</span>);    }    <span class="hljs-comment">//选择搜索结果的第一项</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">chooseResult</span><span class="hljs-params">()</span> {        sleep(<span class="hljs-number">3000</span>);        <span class="hljs-type">WebElement</span> <span class="hljs-variable">chosen</span> <span class="hljs-operator">=</span> driver.findElement            (By.cssSelector(<span class="hljs-string">".a-link-normal:first-child"</span>));        chosen.click();    }    <span class="hljs-comment">//加入购物车</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addToCart</span><span class="hljs-params">()</span> {        sleep(<span class="hljs-number">1500</span>);        <span class="hljs-type">WebElement</span> <span class="hljs-variable">tag</span> <span class="hljs-operator">=</span> driver.findElement(By.id(<span class="hljs-string">"mediaTab_heading_1"</span>));        tag.click();        sleep(<span class="hljs-number">1500</span>);        <span class="hljs-type">WebElement</span> <span class="hljs-variable">toBuy</span> <span class="hljs-operator">=</span> driver.findElement(By.id(<span class="hljs-string">"a-autoid-2-announce"</span>));        toBuy.click();        sleep(<span class="hljs-number">2000</span>);        <span class="hljs-type">WebElement</span> <span class="hljs-variable">addToCart</span> <span class="hljs-operator">=</span> driver.findElement(By.name(<span class="hljs-string">"submit.addToCart"</span>));        addToCart.click();        sleep(<span class="hljs-number">2000</span>);        <span class="hljs-type">WebElement</span> <span class="hljs-variable">option_cart</span> <span class="hljs-operator">=</span> driver.findElement(By.id(<span class="hljs-string">"hlb-view-cart-announce"</span>));        option_cart.click();    }}</code></pre><h2 id="白盒测试"><a href="#白盒测试" class="headerlink" title="白盒测试"></a>白盒测试</h2><h3 id="概念-2"><a href="#概念-2" class="headerlink" title="概念"></a>概念</h3><h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><p>白盒测试又叫结构测试，逻辑驱动测试或基于程序本身的测试。 </p><h4 id="动态测试"><a href="#动态测试" class="headerlink" title="动态测试"></a>动态测试</h4><h5 id="逻辑覆盖"><a href="#逻辑覆盖" class="headerlink" title="逻辑覆盖"></a>逻辑覆盖</h5><blockquote><p>每一个标准的含义 </p></blockquote><ul><li><p>语句覆盖 </p><p>设计若干条测试用例，使程序中每条可执行语句至少执行一次。</p></li><li><p>判定覆盖（分支覆盖） </p><p>设计测试用例，使程序中的每个逻辑判断的取真和取假的分支至少经历一次。</p></li><li><p>条件覆盖 </p><p>设计若干测试用例，使程序的每个判定中的每个条件的可能取值至少满足一次</p></li><li><p>判定-条件覆盖 </p><p>使判定中每个条件的可能取值至少满足一次，并且使每个判定分支至少执行一次。 </p><p>判定-条件覆盖能同时满足判定、条件两种覆盖标准。</p></li><li><p>条件组合覆盖 </p><p>设计用例，使得每个判断表达式中条件的各种可能组合都至少出现一次；</p></li><li><p>路径覆盖</p><p>设计足够多的测试用例，覆盖程序中的每条可能路径。</p></li></ul><pre><code class="hljs mermaid">graph TDA[语句覆盖] --&gt; B[判定覆盖]A[语句覆盖] --&gt; C[条件覆盖]B[判定覆盖] --&gt; D[判定/条件覆盖]C[条件覆盖] --&gt; D[判定/条件覆盖]D--&gt;E[条件组合覆盖]--&gt;F[路径覆盖]</code></pre><h5 id="写覆盖"><a href="#写覆盖" class="headerlink" title="写覆盖"></a>写覆盖</h5><ul><li><p>Draw the CFG for the code fragment.</p></li><li><p>Compute the cyclomatic complexity number C, for the CFG.</p><ul><li>Cyclomatic complexity <ul><li>The number of ‘regions’ in the graph;  </li><li>The number of predicates + 1</li></ul></li></ul></li><li><p>Find at most C paths that cover the nodes and arcs in a CFG, also known as Basic Paths Set;</p></li><li><p>Design test cases to force execution along paths in the Basic Paths Set.</p></li></ul><h5 id="Junit写代码"><a href="#Junit写代码" class="headerlink" title="Junit写代码"></a>Junit写代码</h5><ul><li><p>The annotations in Junit</p><ul><li><p>@Test public void method()<br> this means the method is used to test the other methods.</p></li><li><p>@Before public void method()<br> the method is always executed before every test method is executed. It is usually used to prepare some data, or give some initial values.</p></li><li><p>@After public void method()<br> the method is always executed after every test method is executed. It is usually used to free up some storage space.</p></li><li><p>@BeforeClass public static void method()</p><p>the method is only executed once before all test methods are executed. It is usually used to do what all methods depend on, like connecting database.</p></li><li><p>@AfterClass public static void method()<br> contrary to @BeforeClass</p></li><li><p>@Ignore public void method()<br> the method will be ignored.</p></li><li><p>@Test(expected=IllegalArgumentException.class)<br>Check if the exception can be thrown</p><pre><code class="hljs java"><span class="hljs-meta">@Test(expected=ArithmeticException.class)</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testDiv</span><span class="hljs-params">()</span> {    Math demoMath=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Math</span>();    <span class="hljs-type">int</span> expected;<span class="hljs-comment">// expected result</span>    <span class="hljs-type">int</span> actualvalue;<span class="hljs-comment">// actual result</span>    expected=<span class="hljs-number">2</span>;    actualvalue=demoMath.div(<span class="hljs-number">1</span>, <span class="hljs-number">0</span>);    assertEquals(expected, actualvalue);}</code></pre></li><li><p>@Test(timeout=100)<br>If the execution time of the method is greater than 100ms, the test fails.</p><pre><code class="hljs java"><span class="hljs-meta">@Test(timeout=1)</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testDiv</span><span class="hljs-params">()</span> {    Math demoMath=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Math</span>();    <span class="hljs-type">int</span> expected;<span class="hljs-comment">//expected result</span>    <span class="hljs-type">int</span> actualvalue;<span class="hljs-comment">//actual result</span>    expected=<span class="hljs-number">2</span>;    actualvalue=demoMath.div(<span class="hljs-number">2</span>, <span class="hljs-number">1</span>);    assertEquals(expected, actualvalue);}</code></pre></li></ul></li><li><p>Assertion methods</p><ul><li>assertEquals</li><li>assertArrayEquals</li><li>assertFalse</li><li>assertTrue</li><li>assertNull</li><li>assertNotNull</li><li>assertSame</li><li>assertNotSame</li><li>…….</li></ul></li></ul><h2 id="性能测试"><a href="#性能测试" class="headerlink" title="性能测试"></a>性能测试</h2><h3 id="概念-3"><a href="#概念-3" class="headerlink" title="概念"></a>概念</h3><p>性能测试是通过自动化的测试工具模拟多种正常、峰值以及异常负载条件来对系统的各项性能指标进行测试。</p><p><img src="/images/st2.png" alt="st2"></p>]]></content>
      
      
      
        <tags>
            
            <tag> SE </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++ 11 &amp; C++14</title>
      <link href="/2021/03/10/CplusplusScroll/"/>
      <url>/2021/03/10/CplusplusScroll/</url>
      
        <content type="html"><![CDATA[<p><img src="/images/cpp.png" alt="cpp"></p><h2 id="语言可用性强化"><a href="#语言可用性强化" class="headerlink" title="语言可用性强化"></a>语言可用性强化</h2><h3 id="nullptr-与-constexpr"><a href="#nullptr-与-constexpr" class="headerlink" title="nullptr 与 constexpr"></a>nullptr 与 constexpr</h3><h3 id="类型推导"><a href="#类型推导" class="headerlink" title="类型推导"></a>类型推导</h3><p>在传统 C 和 C++中，参数的类型都必须明确定义，尤其是当我们面对一大堆复杂的模板类型时，必须明确的指出变量的类型才能进行后续的编码。</p><p>C++ 11 引入了 <code>auto</code> 和 <code>decltype</code> 这两个关键字实现了类型推导，让编译器来操心变量的类型。这使得 C++ 也具有了和其他现代编程语言一样，某种意义上提供了无需操心变量类型的使用习惯。</p><h4 id="auto"><a href="#auto" class="headerlink" title="auto"></a>auto</h4><p><code>auto</code> 在很早以前就已经进入了 C++，但是他始终作为一个存储类型的指示符存在，与 <code>register</code> 并存。</p><p>不使用auto书写迭代器:</p><pre><code class="hljs c++"><span class="hljs-keyword">for</span>(vector&lt;<span class="hljs-type">int</span>&gt;::const_iterator itr = vec.<span class="hljs-built_in">cbegin</span>(); itr != vec.<span class="hljs-built_in">cend</span>(); ++itr)</code></pre><p>使用auto:</p><pre><code class="hljs c++"><span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> itr = vec.<span class="hljs-built_in">cbegin</span>(); itr != vec.<span class="hljs-built_in">cend</span>(); ++itr);</code></pre><p>其它用法：</p><pre><code class="hljs c++"><span class="hljs-keyword">auto</span> i = <span class="hljs-number">5</span>;<span class="hljs-comment">//i被推导为 int</span><span class="hljs-keyword">auto</span> arr = <span class="hljs-keyword">new</span> <span class="hljs-built_in">auto</span>(<span class="hljs-number">10</span>);<span class="hljs-comment">//arr被推导为 int *</span></code></pre><p>notice: <code>auto</code> 不可用于函数传参和推导数组类型，如以下错误：</p><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-keyword">auto</span> x, <span class="hljs-keyword">auto</span> y)</span></span>;{    <span class="hljs-keyword">auto</span> i = <span class="hljs-number">5</span>;    <span class="hljs-type">int</span> arr[<span class="hljs-number">10</span>] = {<span class="hljs-number">0</span>};    <span class="hljs-keyword">auto</span> auto_arr = arr;    <span class="hljs-keyword">auto</span> auto_arr2[<span class="hljs-number">10</span>] = arr;}</code></pre><h4 id="decltype"><a href="#decltype" class="headerlink" title="decltype"></a>decltype</h4><p><code>decltype</code> 关键字是为了解决 auto 关键字只能对变量进行类型推导的缺陷而出现的，其用法和<code>sizeof</code> 相似：</p><pre><code class="hljs c++"><span class="hljs-keyword">decltype</span>(表达式);<span class="hljs-comment">//编译器分析表达式并得到其类型，却得不到其值</span><span class="hljs-comment">//计算某表达式的值</span><span class="hljs-keyword">auto</span> x = <span class="hljs-number">1</span>;<span class="hljs-keyword">auto</span> y = <span class="hljs-number">2</span>;<span class="hljs-keyword">decltype</span>(x + y) z;  <span class="hljs-comment">//z为int型</span></code></pre><h4 id="尾返回类型、auto与decltype配合"><a href="#尾返回类型、auto与decltype配合" class="headerlink" title="尾返回类型、auto与decltype配合"></a>尾返回类型、auto与decltype配合</h4><p>以下写法不能通过编译：</p><pre><code class="hljs c++"><span class="hljs-keyword">decltype</span>(x + y) <span class="hljs-built_in">add</span>(T x, U y);</code></pre><p>C++11引入尾返回类型（trailing return type),利用<code>auto</code> 将返回类型后置:</p><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T, <span class="hljs-keyword">typename</span> U&gt;</span><span class="hljs-function"><span class="hljs-keyword">auto</span> <span class="hljs-title">add</span><span class="hljs-params">(T x, U y)</span> -&gt; <span class="hljs-title">decltype</span><span class="hljs-params">(x + y)</span> </span>{    <span class="hljs-keyword">return</span> x + y;}</code></pre><p>自C++14始，可直接让普通函数具备返回值推导，以下合法：</p><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">template</span> T, <span class="hljs-keyword">typename</span> U&gt;</span><span class="hljs-function"><span class="hljs-keyword">auto</span> <span class="hljs-title">add</span><span class="hljs-params">(T x, U y)</span> </span>{    <span class="hljs-keyword">return</span> x + y;}</code></pre><h3 id="区间迭代"><a href="#区间迭代" class="headerlink" title="区间迭代"></a>区间迭代</h3><p>区间迭代是指基于范围的 for 循环。</p><pre><code class="hljs c++"><span class="hljs-type">int</span> array[] = {<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>};<span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> &amp;x : array) {    std::cout &lt;&lt; x &lt;&lt; std::endl;}<span class="hljs-comment">//std::vector的遍历</span><span class="hljs-comment">//不使用区间迭代</span><span class="hljs-function">std::vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">arr</span><span class="hljs-params">(<span class="hljs-number">5</span>, <span class="hljs-number">100</span>)</span></span>;<span class="hljs-keyword">for</span>(std::vector&lt;<span class="hljs-type">int</span>&gt;::iterator i = arr.<span class="hljs-built_in">begin</span>(); i != arr.<span class="hljs-built_in">end</span>(); ++i) {    std::cout&lt;&lt; *i &lt;&lt; std::endl;}<span class="hljs-comment">//使用区间迭代</span><span class="hljs-comment">//&amp;启用引用，若无则元素可读不可修改</span><span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> &amp;i : arr) {    std::cout&lt;&lt; i &lt;&lt; std::endl;}</code></pre><h3 id="初始化列表"><a href="#初始化列表" class="headerlink" title="初始化列表"></a>初始化列表</h3><p>在传统 C++ 中，不同的对象有着不同的初始化方法，例如普通数组、POD （plain old data，没有构造、析构和虚函数的类或结构体）类型都可以使用 <code>{}</code> 进行初始化，也就是我们所说的初始化列表。而对于类对象的初始化，要么需要通过拷贝构造、要么就需要使用 <code>()</code> 进行。这些不同方法都针对各自对象，不能通用。</p><pre><code class="hljs c++"><span class="hljs-type">int</span> arr[<span class="hljs-number">3</span>] = {<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>};   <span class="hljs-comment">// 列表初始化</span><span class="hljs-keyword">class</span> <span class="hljs-title class_">Foo</span> {    <span class="hljs-keyword">private</span>:        <span class="hljs-type">int</span> value;    <span class="hljs-keyword">public</span>:        <span class="hljs-built_in">Foo</span>(<span class="hljs-type">int</span>) {}};<span class="hljs-function">Foo <span class="hljs-title">foo</span><span class="hljs-params">(<span class="hljs-number">1</span>)</span></span>;             <span class="hljs-comment">// 普通构造初始化</span></code></pre><p>在C++11中使用<code>std::initializer_list</code> 类型允许构造函数或其它函数像参数一样使用初始化列表，这就为类对象的初始化与普通数组和 POD 的初始化方法提供了统一的桥梁，如：</p><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;initializer_list&gt;</span></span><span class="hljs-keyword">class</span> <span class="hljs-title class_">Happiness</span> {    <span class="hljs-keyword">public</span>:    <span class="hljs-comment">//初始化列表构造函数</span>    <span class="hljs-built_in">Happiness</span>(std::initializer_list&lt;<span class="hljs-type">int</span>&gt; list) {}};Happiness happiness = {<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>};std::vector&lt;<span class="hljs-type">int</span>&gt; v = {<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>};<span class="hljs-comment">//初始化列表作为普通函数的形参</span><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">(std::initializer_list&lt;<span class="hljs-type">int</span>&gt; list)</span></span><span class="hljs-function"></span>{    <span class="hljs-keyword">return</span>;}<span class="hljs-built_in">func</span>({<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>});<span class="hljs-comment">//C++11提供统一语法以初始化任意对象 </span><span class="hljs-keyword">struct</span> <span class="hljs-title class_">A</span> {    <span class="hljs-type">int</span> a;    <span class="hljs-type">float</span> b;};<span class="hljs-keyword">struct</span> <span class="hljs-title class_">B</span> {    <span class="hljs-built_in">B</span>(<span class="hljs-type">int</span> _a, <span class="hljs-type">float</span> _b): <span class="hljs-built_in">a</span>(_a), <span class="hljs-built_in">b</span>(_b) {}    <span class="hljs-keyword">private</span>:    <span class="hljs-type">int</span> a;    <span class="hljs-type">float</span> b;};A a {<span class="hljs-number">1</span>, <span class="hljs-number">1.1</span>};B b {<span class="hljs-number">2</span>, <span class="hljs-number">2.2</span>};</code></pre><h3 id="模板增强"><a href="#模板增强" class="headerlink" title="模板增强"></a>模板增强</h3><h4 id="外部模板"><a href="#外部模板" class="headerlink" title="外部模板"></a>外部模板</h4><p>传统 C++ 中，模板只有在使用时才会被编译器实例化。换句话说，只要在每个编译单元（文件）中编译的代码中遇到了被完整定义的模板，都会实例化。这就产生了重复实例化而导致的编译时间的增加。并且，我们没有办法通知编译器不要触发模板实例化。</p><p>C++11 引入了外部模板，扩充了原来的强制编译器在特定位置实例化模板的语法，使得能够显式的告诉编译器何时进行模板的实例化：</p><pre><code class="hljs c++"><span class="hljs-keyword">template</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">std</span>::vector&lt;<span class="hljs-type">bool</span>&gt;;<span class="hljs-comment">//强制实例化</span><span class="hljs-keyword">extern</span> <span class="hljs-keyword">template</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">std</span>::vector&lt;<span class="hljs-type">double</span>&gt;   <span class="hljs-comment">//不再该编译文件中实例化模板</span></code></pre><h4 id="尖括号”-”"><a href="#尖括号”-”" class="headerlink" title="尖括号”>”"></a>尖括号”&gt;”</h4><p>在传统 C++ 的编译器中，<code>&gt;&gt;</code>一律被当做右移运算符来进行处理，而自C++ 11 始，连续的右尖括号将变得合法，并且能够顺利通过编译:</p><pre><code class="hljs c++"><span class="hljs-comment">//嵌套模板</span>std::vector&lt;std::vector&lt;<span class="hljs-type">int</span>&gt;&gt; wow;</code></pre><h4 id="类型别名模板"><a href="#类型别名模板" class="headerlink" title="类型别名模板"></a>类型别名模板</h4><p>模板是用来产生类型的，模板不是类型。在传统 C++中，<code>typedef</code> 可以为类型定义一个新的名称，但是却没有办法为模板定义一个新的名称。</p><pre><code class="hljs c++"><span class="hljs-keyword">template</span>&lt; <span class="hljs-keyword">typename</span> T, <span class="hljs-keyword">typename</span> U, <span class="hljs-type">int</span> value&gt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">SuckType</span> {<span class="hljs-keyword">public</span>:    T a;    U b;    <span class="hljs-built_in">SuckType</span>():<span class="hljs-built_in">a</span>(value),<span class="hljs-built_in">b</span>(value){}};<span class="hljs-keyword">template</span>&lt; <span class="hljs-keyword">typename</span> U&gt;<span class="hljs-keyword">typedef</span> SuckType&lt;std::vector&lt;<span class="hljs-type">int</span>&gt;, U, <span class="hljs-number">1</span>&gt; NewType; <span class="hljs-comment">// 不合法</span></code></pre><p>C++ 11 使用 <code>using</code> 引入了下面这种形式的写法，并且同时支持对传统 <code>typedef</code> 相同的功效：</p><pre><code class="hljs c++"><span class="hljs-comment">//通常我们使用 typedef 定义别名的语法是：typedef 原名称 新名称;</span><span class="hljs-comment">//但是对函数指针等别名的定义语法却不相同，这通常给直接阅读造成了一定程度的困难。</span><span class="hljs-function"><span class="hljs-keyword">typedef</span> <span class="hljs-title">int</span> <span class="hljs-params">(*process)</span><span class="hljs-params">(<span class="hljs-type">void</span> *)</span></span>;  <span class="hljs-comment">// 定义了一个返回类型为 int，参数为 void* 的函数指针类型，名字叫做 process</span><span class="hljs-keyword">using</span> process = <span class="hljs-built_in">int</span>(*)(<span class="hljs-type">void</span> *); <span class="hljs-comment">// 同上, 更加直观</span><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<span class="hljs-keyword">using</span> NewType = SuckType&lt;<span class="hljs-type">int</span>, T, <span class="hljs-number">1</span>&gt;;    <span class="hljs-comment">// 合法</span></code></pre><h4 id="默认模板参数"><a href="#默认模板参数" class="headerlink" title="默认模板参数"></a>默认模板参数</h4><p>定义一个加法函数：</p><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T, <span class="hljs-keyword">typename</span> U&gt;</span><span class="hljs-function"><span class="hljs-keyword">auto</span> <span class="hljs-title">add</span><span class="hljs-params">(T x, U y)</span> -&gt; <span class="hljs-title">decltype</span><span class="hljs-params">(x+y)</span> </span>{    <span class="hljs-keyword">return</span> x+y}</code></pre><p>要使用 add，就必须每次都指定其模板参数的类型。在 C++11 中提供了一种便利，可以指定模板的默认参数：</p><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T </span>= <span class="hljs-type">int</span>, <span class="hljs-keyword">typename</span> U = <span class="hljs-type">int</span>&gt;<span class="hljs-keyword">auto</span> <span class="hljs-built_in">add</span>(T x, U y) -&gt; <span class="hljs-keyword">decltype</span>(x+y) {    <span class="hljs-keyword">return</span> x+y;}</code></pre><h4 id="变长参数模板"><a href="#变长参数模板" class="headerlink" title="变长参数模板"></a>变长参数模板</h4><p>模板一直是 C++ 所独有的黑魔法（<strong>Dark Magic</strong>）之一。在 C++11 之前，无论是类模板还是函数模板，都只能按其指定的样子，接受一组固定数量的模板参数；而 C++11 加入了新的表示方法，允许任意个数、任意类别的模板参数，同时也不需要在定义时将参数的个数固定。</p><pre><code class="hljs c++"><span class="hljs-comment">//任意个数、任意类别的模板参数</span><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span>... Ts&gt; <span class="hljs-keyword">class</span> <span class="hljs-title class_">Magic</span>;</code></pre><p>模板类 Magic 的对象，能够接受不受限制个数的 typename 作为模板的形式参数:</p><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Magic</span>&lt;<span class="hljs-type">int</span>,            std::vector&lt;<span class="hljs-type">int</span>&gt;,            std::map&lt;std::string,                     std::vector&lt;<span class="hljs-type">int</span>&gt;&gt;&gt; darkMagic;</code></pre><p>既然是任意形式，所以个数为 0 的模板参数也是可以的：<code>class Magic&lt;&gt; nothing;</code>，如果不希望产生的模板参数个数为 0，可以手动的定义至少一个模板参数：</p><pre><code class="hljs c++"><span class="hljs-comment">//手动定义至少一个模板参数</span><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> Require, <span class="hljs-keyword">typename</span>... Args&gt; <span class="hljs-keyword">class</span> <span class="hljs-title class_">Magic</span>;</code></pre><p>变长参数模板也能被直接调整到到模板函数上：</p><pre><code class="hljs c++"><span class="hljs-comment">//传统 C 中的 printf 函数，虽然也能达成不定个数的形参的调用，但其并非类别安全</span><span class="hljs-comment">//C++11 除了能定义类别安全的变长参数函数外，还可以使类似 printf 的函数能自然地处理非自带类别的对象</span><span class="hljs-comment">//函数参数也使用 ... 代表不定长参数</span><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span>... Args&gt; <span class="hljs-type">void</span> <span class="hljs-title">printf</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string &amp;str, Args... args)</span></span>;</code></pre><p>如何对变长的模板参数进行解包：</p><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span>... Args&gt;</span><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">magic</span><span class="hljs-params">(Args... args)</span> </span>{    std::cout &lt;&lt; <span class="hljs-keyword">sizeof</span>...(args) &lt;&lt; std::endl;}<span class="hljs-comment">//我们可以传递任意个参数给 magic 函数：</span><span class="hljs-built_in">magic</span>();        <span class="hljs-comment">// 输出0</span><span class="hljs-built_in">magic</span>(<span class="hljs-number">1</span>);       <span class="hljs-comment">// 输出1</span><span class="hljs-built_in">magic</span>(<span class="hljs-number">1</span>, <span class="hljs-string">""</span>);   <span class="hljs-comment">// 输出2</span></code></pre><p>对参数进行解包，到目前为止还没有一种简单的方法能够处理参数包，但有两种经典的处理手法：</p><h5 id="1-递归模板函数"><a href="#1-递归模板函数" class="headerlink" title="1. 递归模板函数"></a>1. 递归模板函数</h5><p>递归是非常容易想到的一种手段，也是最经典的处理方法。这种方法不断递归的向函数传递模板参数，进而达到递归遍历所有模板参数的目的：</p><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;</span><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">printf</span><span class="hljs-params">(T value)</span> </span>{    std::cout &lt;&lt; value &lt;&lt; std::endl;}<span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T, <span class="hljs-keyword">typename</span>... Args&gt;</span><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">printf</span><span class="hljs-params">(T value, Args... args)</span> </span>{    std::cout &lt;&lt; value &lt;&lt; std::endl;    <span class="hljs-built_in">printf</span>(args...);}<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{    <span class="hljs-built_in">printf</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-string">"123"</span>, <span class="hljs-number">1.1</span>);    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;}</code></pre><h5 id="2-初始化列表展开"><a href="#2-初始化列表展开" class="headerlink" title="2. 初始化列表展开"></a>2. 初始化列表展开</h5><p>递归模板函数是一种标准的做法，但缺点显而易见的在于必须定义一个终止递归的函数。以下记录了使用初始化列表展开的方法（<strong>黑魔法</strong>）：</p><pre><code class="hljs c++"><span class="hljs-comment">// 编译这个代码需要开启 -std=c++14</span><span class="hljs-comment">//通过初始化列表，(lambda 表达式, value)... 将会被展开。</span><span class="hljs-comment">//由于逗号表达式的出现，首先会执行前面的 lambda 表达式，完成参数的输出。</span><span class="hljs-comment">//唯一不美观的地方在于如果不使用 return 编译器会给出未使用的变量作为警告。</span><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T, <span class="hljs-keyword">typename</span>... Args&gt;</span><span class="hljs-function"><span class="hljs-keyword">auto</span> <span class="hljs-title">print</span><span class="hljs-params">(T value, Args... args)</span> </span>{    std::cout &lt;&lt; value &lt;&lt; std::endl;    <span class="hljs-keyword">return</span> std::initializer_list&lt;T&gt;{([&amp;] {        std::cout &lt;&lt; args &lt;&lt; std::endl;    }(), value)...};}<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{    <span class="hljs-built_in">print</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2.1</span>, <span class="hljs-string">"123"</span>);    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;}</code></pre><h3 id="面向对象增强"><a href="#面向对象增强" class="headerlink" title="面向对象增强"></a>面向对象增强</h3><h4 id="委托构造"><a href="#委托构造" class="headerlink" title="委托构造"></a>委托构造</h4><p>C++ 11 引入了委托构造的概念，这使得在同一个类中一个构造函数调用另一个构造函数，从而达到<strong>简化代码</strong>的目的：</p><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Base</span> {<span class="hljs-keyword">public</span>:    <span class="hljs-type">int</span> value1;    <span class="hljs-type">int</span> value2;    <span class="hljs-built_in">Base</span>() {        value1 = <span class="hljs-number">1</span>;    }    <span class="hljs-built_in">Base</span>(<span class="hljs-type">int</span> value) : <span class="hljs-built_in">Base</span>() {  <span class="hljs-comment">// 委托 Base() 构造函数</span>        value2 = <span class="hljs-number">2</span>;    }};<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{    <span class="hljs-function">Base <span class="hljs-title">b</span><span class="hljs-params">(<span class="hljs-number">2</span>)</span></span>;    std::cout &lt;&lt; b.value1 &lt;&lt; std::endl;    std::cout &lt;&lt; b.value2 &lt;&lt; std::endl;}</code></pre><h4 id="继承构造"><a href="#继承构造" class="headerlink" title="继承构造"></a>继承构造</h4><p>在传统 C++ 中，构造函数如果需要继承是需要将参数一一传递的，这将导致效率低下。C++ 11 利用关键字 using 引入了继承构造函数的概念：</p><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Base</span> {<span class="hljs-keyword">public</span>:    <span class="hljs-type">int</span> value1;    <span class="hljs-type">int</span> value2;    <span class="hljs-built_in">Base</span>() {        value1 = <span class="hljs-number">1</span>;    }    <span class="hljs-built_in">Base</span>(<span class="hljs-type">int</span> value) : <span class="hljs-built_in">Base</span>() {           <span class="hljs-comment">// 委托 Base() 构造函数</span>        value2 = <span class="hljs-number">2</span>;    }};<span class="hljs-keyword">class</span> <span class="hljs-title class_">Subclass</span> : <span class="hljs-keyword">public</span> Base {<span class="hljs-keyword">public</span>:    <span class="hljs-keyword">using</span> Base::Base;                   <span class="hljs-comment">// 继承构造</span>};<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{    <span class="hljs-function">Subclass <span class="hljs-title">s</span><span class="hljs-params">(<span class="hljs-number">3</span>)</span></span>;    std::cout &lt;&lt; s.value1 &lt;&lt; std::endl;    std::cout &lt;&lt; s.value2 &lt;&lt; std::endl;}</code></pre><h4 id="显式虚函数重载"><a href="#显式虚函数重载" class="headerlink" title="显式虚函数重载"></a>显式虚函数重载</h4><p>在传统 C++ 中，经常容易发生意外重载虚函数的事情，如：</p><pre><code class="hljs c++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Base</span> {    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">foo</span><span class="hljs-params">()</span></span>;};<span class="hljs-keyword">struct</span> <span class="hljs-title class_">SubClass</span>: Base {    <span class="hljs-comment">//可能是恰好加入的与基类中同名的函数或重载虚函数</span>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">foo</span><span class="hljs-params">()</span></span>;};</code></pre><p>C++ 11 引入了 <code>override</code> 和 <code>final</code> 这两个关键字来防止上述情形的发生：</p><h5 id="override"><a href="#override" class="headerlink" title="override"></a>override</h5><p>当重载虚函数时，引入 <code>override</code> 关键字将显式的告知编译器进行重载，编译器将检查基函数是否存在这样的虚函数，否则将无法通过编译：</p><pre><code class="hljs c++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Base</span> {    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">foo</span><span class="hljs-params">(<span class="hljs-type">int</span>)</span></span>;};<span class="hljs-keyword">struct</span> <span class="hljs-title class_">SubClass</span>: Base {    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">foo</span><span class="hljs-params">(<span class="hljs-type">int</span>)</span> <span class="hljs-keyword">override</span></span>; <span class="hljs-comment">// 合法</span>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">foo</span><span class="hljs-params">(<span class="hljs-type">float</span>)</span> <span class="hljs-keyword">override</span></span>; <span class="hljs-comment">// 非法, 父类没有此虚函数</span>};</code></pre><h5 id="final"><a href="#final" class="headerlink" title="final"></a>final</h5><p><code>final</code> 则是为了防止类被继续继承以及终止虚函数继续重载引入的。</p><pre><code class="hljs c++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Base</span> {        <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">foo</span><span class="hljs-params">()</span> <span class="hljs-keyword">final</span></span>;};<span class="hljs-keyword">struct</span> <span class="hljs-title class_">SubClass1</span> <span class="hljs-keyword">final</span>: Base {};                  <span class="hljs-comment">// 合法</span><span class="hljs-keyword">struct</span> <span class="hljs-title class_">SubClass2</span> : SubClass1 {};                  <span class="hljs-comment">// 非法, SubClass 已 final</span><span class="hljs-keyword">struct</span> <span class="hljs-title class_">SubClass3</span>: Base {        <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">foo</span><span class="hljs-params">()</span></span>; <span class="hljs-comment">// 非法, foo 已 final</span>};</code></pre><h5 id="显式禁用默认函数"><a href="#显式禁用默认函数" class="headerlink" title="显式禁用默认函数"></a>显式禁用默认函数</h5><p>在传统 C++ 中，如果程序员没有提供，编译器会默认为对象生成默认构造函数、复制构造、赋值算符以及析构函数。另外，C++ 也为所有类定义了诸如 <code>new</code> <code>delete</code> 这样的运算符。当程序员有需要时，可以重载这部分函数。</p><p>这就引发了一些需求：无法精确控制默认函数的生成行为。例如禁止类的拷贝时，必须将赋值构造函数与赋值算符声明为 <code>private</code>。尝试使用这些未定义的函数将导致编译或链接错误，则是一种非常不优雅的方式。</p><p>并且，编译器产生的默认构造函数与用户定义的构造函数无法同时存在。若用户定义了任何构造函数，编译器将不再生成默认构造函数，但有时候我们却希望同时拥有这两种构造函数，这就造成了尴尬。</p><p>C++11 提供了上述需求的解决方案，允许显式的声明采用或拒绝编译器自带的函数，如：</p><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Magic</span> {<span class="hljs-keyword">public</span>:    <span class="hljs-built_in">Magic</span>() = <span class="hljs-keyword">default</span>;  <span class="hljs-comment">// 显式声明使用编译器生成的构造</span>    Magic&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> Magic&amp;) = <span class="hljs-keyword">delete</span>; <span class="hljs-comment">// 显式声明拒绝编译器生成构造</span>    <span class="hljs-built_in">Magic</span>(<span class="hljs-type">int</span> magic_number);}</code></pre><h3 id="强类型枚举"><a href="#强类型枚举" class="headerlink" title="强类型枚举"></a>强类型枚举</h3><p>在传统 C++ 中，枚举类型并非类型安全，枚举类型会被视作整数，则会让两种完全不同的枚举类型可以进行直接的比较（虽然编译器给出了检查，但并非所有），<strong>甚至枚举类型的枚举值名字不能相同</strong>，这不是我们希望看到的结果。</p><p>C++ 11 引入了枚举类（enumaration class），并使用 <code>enum class</code> 的语法进行声明：</p><pre><code class="hljs c++"><span class="hljs-keyword">enum class</span> <span class="hljs-title class_">new_enum</span> : <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> {    value1,    value2,    value3 = <span class="hljs-number">100</span>,    value4 = <span class="hljs-number">100</span>};</code></pre><p>这样定义的枚举实现了类型安全，首先他不能够被隐式的转换为整数，同时也不能够将其与整数数字进行比较，更不可能对不同的枚举类型的枚举值进行比较。但相同枚举值之间如果指定的值相同，那么可以进行比较：</p><pre><code class="hljs c++"><span class="hljs-keyword">if</span> (new_enum::value3 == new_enum::value4) {    <span class="hljs-comment">// 会输出</span>    std::cout &lt;&lt; <span class="hljs-string">"new_enum::value3 == new_enum::value4"</span> &lt;&lt; std::endl;}</code></pre><p>在这个语法中，枚举类型后面使用了冒号及类型关键字来指定枚举中枚举值的类型，这使得我们能够为枚举赋值（未指定时将默认使用 int）。</p><p>而我们希望获得枚举值的值时，将必须显式的进行类型转换，不过我们可以通过重载 <code>&lt;&lt;</code> 这个算符来进行输出：</p><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;std::ostream&amp; <span class="hljs-keyword">operator</span>&lt;&lt;(<span class="hljs-keyword">typename</span> std::enable_if&lt;std::is_enum&lt;T&gt;::value, std::ostream&gt;::type&amp; stream, <span class="hljs-type">const</span> T&amp; e){    <span class="hljs-keyword">return</span> stream &lt;&lt; <span class="hljs-keyword">static_cast</span>&lt;<span class="hljs-keyword">typename</span> std::underlying_type&lt;T&gt;::type&gt;(e);}std::cout &lt;&lt; new_enum::value3 &lt;&lt; std::endl</code></pre><h2 id="语言运行期强化"><a href="#语言运行期强化" class="headerlink" title="语言运行期强化"></a>语言运行期强化</h2><h3 id="Lambda表达式"><a href="#Lambda表达式" class="headerlink" title="Lambda表达式"></a>Lambda表达式</h3><p>Lambda 表达式是 C++ 11 中最重要的新特性之一，而 Lambda 表达式，实际上就是提供了一个类似匿名函数的特性，而匿名函数则是在需要一个函数，但是又不想费力去命名一个函数的情况下去使用的。这样的场景其实有很多很多，所以匿名函数几乎是现代编程语言的标配。</p><h4 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h4><p>Lambda 表达式的基本语法如下：</p><pre><code class="hljs c++">[捕获列表](参数列表) <span class="hljs-built_in">mutable</span>(可选) 异常属性 -&gt; 返回类型 {    <span class="hljs-comment">// 函数体</span>}[ caputrue ] ( params ) opt -&gt; ret { body; };</code></pre><p>所谓捕获列表，其实可以理解为参数的一种类型，lambda 表达式内部函数体在默认情况下是不能够使用函数体外部的变量的，这时候捕获列表可以起到传递外部数据的作用。</p><p>根据传递的行为，捕获列表也分为以下几种：</p><h4 id="值捕获"><a href="#值捕获" class="headerlink" title="值捕获"></a>值捕获</h4><p>与参数传值类似，值捕获的前提是变量可以拷贝，不同之处则在于，被捕获的变量在 lambda 表达式被创建时拷贝，而非调用时才拷贝：</p><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">learn_lambda_func_1</span><span class="hljs-params">()</span> </span>{    <span class="hljs-type">int</span> value_1 = <span class="hljs-number">1</span>;    <span class="hljs-keyword">auto</span> copy_value_1 = [value_1] {        <span class="hljs-keyword">return</span> value_1;    };    value_1 = <span class="hljs-number">100</span>;    <span class="hljs-keyword">auto</span> stored_value_1 = <span class="hljs-built_in">copy_value_1</span>();    <span class="hljs-comment">// 这时, stored_value_1 == 1, 而 value_1 == 100.</span>    <span class="hljs-comment">// 因为 copy_value_1 在创建时就保存了一份 value_1 的拷贝</span>    cout &lt;&lt; <span class="hljs-string">"value_1 = "</span> &lt;&lt; value_1 &lt;&lt; endl;    cout &lt;&lt; <span class="hljs-string">"stored_value_1 = "</span> &lt;&lt; stored_value_1 &lt;&lt; endl;}</code></pre><h4 id="引用捕获"><a href="#引用捕获" class="headerlink" title="引用捕获"></a>引用捕获</h4><p>与引用传参类似，引用捕获保存的是引用，值会发生变化。</p><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">learn_lambda_func_2</span><span class="hljs-params">()</span> </span>{    <span class="hljs-type">int</span> value_2 = <span class="hljs-number">1</span>;    <span class="hljs-keyword">auto</span> copy_value_2 = [&amp;value_2] {        <span class="hljs-keyword">return</span> value_2;    };    value_2 = <span class="hljs-number">100</span>;    <span class="hljs-keyword">auto</span> stored_value_2 = <span class="hljs-built_in">copy_value_2</span>();    <span class="hljs-comment">// 这时, stored_value_2 == 100, value_2 == 100.</span>    <span class="hljs-comment">// 因为 copy_value_2 保存的是引用</span>    cout &lt;&lt; <span class="hljs-string">"value_2 = "</span> &lt;&lt; value_2 &lt;&lt; endl;    cout &lt;&lt; <span class="hljs-string">"stored_value_2 = "</span> &lt;&lt; stored_value_2 &lt;&lt; endl;}</code></pre><h4 id="隐式捕获"><a href="#隐式捕获" class="headerlink" title="隐式捕获"></a>隐式捕获</h4><p>手动书写捕获列表有时候是非常复杂的，这种机械性的工作可以交给编译器来处理，这时候可以在捕获列表中写一个 <code>&amp;</code> 或 <code>=</code> 向编译器声明采用引用捕获或者值捕获.</p><p>总结一下，捕获提供了 Lambda 表达式对外部值进行使用的功能，捕获列表的最常用的四种形式可以是：</p><ul><li><code>[]</code> 空捕获列表</li><li><code>[name1, name2, ...]</code> 捕获一系列变量</li><li><code>[&amp;]</code> 引用捕获, 让编译器自行推导捕获列表</li><li><code>[=]</code> 值捕获, 让编译器执行推导应用列表</li></ul><h4 id="表达式捕获（C-14）"><a href="#表达式捕获（C-14）" class="headerlink" title="表达式捕获（C++14）"></a>表达式捕获（C++14）</h4><p>值捕获、引用捕获都是已经在外层作用域声明的变量，因此这些捕获方式捕获的均为左值，而不能捕获右值。</p><p>C++14 允许捕获的成员用任意的表达式进行初始化，这就允许了右值的捕获，被声明的捕获变量类型会根据表达式进行判断，判断方式与使用 <code>auto</code> 本质上是相同的：</p><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;utility&gt;</span></span><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">learn_lambda_func_3</span><span class="hljs-params">()</span></span>{    <span class="hljs-keyword">auto</span> important = std::<span class="hljs-built_in">make_unique</span>&lt;<span class="hljs-type">int</span>&gt;(<span class="hljs-number">1</span>);    <span class="hljs-keyword">auto</span> add = [v1 = <span class="hljs-number">1</span>, v2 = std::<span class="hljs-built_in">move</span>(important)](<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y) -&gt; <span class="hljs-type">int</span> {        <span class="hljs-keyword">return</span> x+y+v1+(*v2);    };    std::cout &lt;&lt; <span class="hljs-string">"add(3, 4) = "</span> &lt;&lt; <span class="hljs-built_in">add</span>(<span class="hljs-number">3</span>, <span class="hljs-number">4</span>) &lt;&lt; std::endl;}</code></pre><p>在上面的代码中，<code>important</code> 是一个独占指针，是不能够被捕获到的，这时候我们需要将其转移为右值，在表达式中初始化。</p><h4 id="泛型Lambda-C-14"><a href="#泛型Lambda-C-14" class="headerlink" title="泛型Lambda(C++ 14)"></a>泛型Lambda(C++ 14)</h4><p>我们知道 <code>auto</code> 关键字不能够用在参数表里，这是因为这样的写法会与模板的功能产生冲突。但是 Lambda 表达式并不是普通函数，所以 Lambda 表达式并不能够模板化。这就为我们造成了一定程度上的麻烦：参数表不能够泛化，必须明确参数表类型。</p><p>然而自 C++14 始，Lambda 函数的形式参数可以使用 <code>auto</code> 关键字来产生意义上的泛型：</p><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">learn_lambda_func_4</span><span class="hljs-params">()</span></span>{    <span class="hljs-keyword">auto</span> generic = [](<span class="hljs-keyword">auto</span> x, <span class="hljs-keyword">auto</span> y) {        <span class="hljs-keyword">return</span> x+y;    };    std::cout &lt;&lt; <span class="hljs-string">"generic(1,2) = "</span> &lt;&lt; <span class="hljs-built_in">generic</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>) &lt;&lt; std::endl;    std::cout &lt;&lt; <span class="hljs-string">"generic(1.1,2.2) = "</span> &lt;&lt; <span class="hljs-built_in">generic</span>(<span class="hljs-number">1.1</span>, <span class="hljs-number">2.2</span>) &lt;&lt; std::endl;}</code></pre><h3 id="函数对象包装器"><a href="#函数对象包装器" class="headerlink" title="函数对象包装器"></a>函数对象包装器</h3><h4 id="std-function"><a href="#std-function" class="headerlink" title="std::function"></a>std::function</h4><p>Lambda 表达式的本质是一个函数对象，当 Lambda 表达式的捕获列表为空时，Lambda 表达式还能够作为一个函数指针进行传递，例如：</p><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><span class="hljs-keyword">using</span> foo = <span class="hljs-built_in">void</span>(<span class="hljs-type">int</span>);  <span class="hljs-comment">// 定义函数指针</span><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">functional</span><span class="hljs-params">(foo f)</span> </span>{    <span class="hljs-built_in">f</span>(<span class="hljs-number">1</span>);}<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{    <span class="hljs-comment">//Lambda表达式的捕获列表为空，可作为函数指针被传递</span>    <span class="hljs-keyword">auto</span> f = [](<span class="hljs-type">int</span> value) {        std::cout &lt;&lt; value &lt;&lt; std::endl;    };    <span class="hljs-built_in">functional</span>(f);  <span class="hljs-comment">// 函数指针调用,f作为函数指针被传递</span>    <span class="hljs-built_in">f</span>(<span class="hljs-number">1</span>);           <span class="hljs-comment">// lambda 表达式调用</span>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;}</code></pre><p>上面的代码给出了两种不同的调用形式，一种是将 Lambda 作为函数指针传递进行调用，而另一种则是直接调用 Lambda 表达式，在 C++11 中，统一了这些概念，将能够被调用的对象的类型，统一称之为可调用类型。而这种类型，便是通过 <code>std::function</code> 引入的。</p><p>C++11 <code>std::function</code> 是一种通用、多态的<strong>函数封装</strong>，它的实例可以对任何可以调用的目标实体进行存储、复制和调用操作，它也是对 C++中现有的可调用实体的一种类型安全的包裹（相对来说，函数指针的调用不是类型安全的），换句话说，就是函数的容器。当我们有了函数的容器之后便能够更加方便的将函数、函数指针作为对象进行处理，如：</p><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;functional&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">foo</span><span class="hljs-params">(<span class="hljs-type">int</span> para)</span> </span>{    <span class="hljs-keyword">return</span> para;}<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{    <span class="hljs-comment">// std::function 包装了一个返回值为 int, 参数为 int 的函数</span>    std::function&lt;<span class="hljs-type">int</span>(<span class="hljs-type">int</span>)&gt; func = foo;    <span class="hljs-type">int</span> important = <span class="hljs-number">10</span>;    std::function&lt;<span class="hljs-type">int</span>(<span class="hljs-type">int</span>)&gt; func2 = [&amp;](<span class="hljs-type">int</span> value) -&gt; <span class="hljs-type">int</span> {        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>+value+important;    };    std::cout &lt;&lt; <span class="hljs-built_in">func</span>(<span class="hljs-number">10</span>) &lt;&lt; std::endl;    std::cout &lt;&lt; <span class="hljs-built_in">func2</span>(<span class="hljs-number">10</span>) &lt;&lt; std::endl;}</code></pre><h4 id="std-bind-std-placeholder"><a href="#std-bind-std-placeholder" class="headerlink" title="std::bind/std::placeholder"></a>std::bind/std::placeholder</h4><p> <code>std::bind</code> 是用来绑定函数调用的参数的，它解决的需求是我们有时候可能并不一定能够一次性获得调用某个函数的全部参数，通过这个函数，我们可以将部分调用参数提前绑定到函数身上成为一个新的对象，然后在参数齐全后，完成调用，如：</p><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">foo</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b, <span class="hljs-type">int</span> c)</span> </span>{    ;}<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{    <span class="hljs-comment">// 将参数1,2绑定到函数 foo 上，但是使用 std::placeholders::_1 来对第一个参数进行占位</span>    <span class="hljs-keyword">auto</span> bindFoo = std::<span class="hljs-built_in">bind</span>(foo, std::placeholders::_1, <span class="hljs-number">1</span>,<span class="hljs-number">2</span>);    <span class="hljs-comment">// 这时调用 bindFoo 时，只需要提供第一个参数即可</span>    <span class="hljs-built_in">bindFoo</span>(<span class="hljs-number">1</span>);}</code></pre><blockquote><p><strong>notice：</strong>注意 <code>auto</code> 关键字的妙用。有时候我们可能不太熟悉一个函数的返回值类型，但是我们却可以通过 <code>auto</code> 的使用来规避这一问题的出现。</p></blockquote><h3 id="右值引用"><a href="#右值引用" class="headerlink" title="右值引用"></a>右值引用</h3><p>右值引用是 C++11 引入的与 Lambda 表达式齐名的重要特性之一。它的引入解决了 C++ 中大量的历史遗留问题，消除了诸如 <code>std::vector</code>、<code>std::string</code> 之类的额外开销，也才使得函数对象容器 <code>std::function</code> 成为了可能。</p><h2 id="新增容器"><a href="#新增容器" class="headerlink" title="新增容器"></a>新增容器</h2><h2 id="智能指针和引用计数"><a href="#智能指针和引用计数" class="headerlink" title="智能指针和引用计数"></a>智能指针和引用计数</h2><h2 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h2><h2 id="语言级线程支持"><a href="#语言级线程支持" class="headerlink" title="语言级线程支持"></a>语言级线程支持</h2><h2 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h2><h2 id="C-17"><a href="#C-17" class="headerlink" title="C++17"></a>C++17</h2>]]></content>
      
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
